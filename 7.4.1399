To: vim_dev@googlegroups.com
Subject: Patch 7.4.1399
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1399
Problem:    The MS-DOS code does not build.
Solution:   Remove the old MS-DOS code.
Files:      Filelist, src/Make_bc3.mak, src/Make_bc5.mak, src/Make_djg.mak,
            src/Makefile, src/blowfish.c, src/buffer.c, src/diff.c,
            src/digraph.c, src/dosinst.h, src/eval.c, src/ex_cmds.c,
            src/ex_cmds2.c, src/ex_docmd.c, src/ex_getln.c, src/feature.h,
            src/fileio.c, src/getchar.c, src/globals.h, src/macros.h,
            src/main.c, src/mbyte.c, src/memfile.c, src/memline.c,
            src/misc1.c, src/misc2.c, src/netbeans.c, src/option.c,
            src/option.h, src/os_msdos.c, src/os_msdos.h, src/proto.h,
            src/proto/os_msdos.pro, src/regexp.c, src/screen.c, src/structs.h,
            src/syntax.c, src/term.c, src/undo.c, src/uninstal.c,
            src/version.c, src/vim.h, src/window.c, src/xxd/Make_bc3.mak,
            src/xxd/Make_djg.mak


*** ../vim-7.4.1398/Filelist	2016-02-20 13:54:39.149146991 +0100
--- Filelist	2016-02-23 13:41:34.381283735 +0100
***************
*** 291,301 ****
  		src/GvimExt/uninst.bat \
  		README_srcdos.txt \
  		src/INSTALLpc.txt \
- 		src/Make_bc3.mak \
  		src/Make_bc5.mak \
  		src/Make_cyg.mak \
  		src/Make_cyg_ming.mak \
- 		src/Make_djg.mak \
  		src/Make_ivc.mak \
  		src/Make_dvc.mak \
  		src/Make_ming.mak \
--- 291,299 ----
***************
*** 321,328 ****
  		src/if_perl_msvc/stdbool.h \
  		src/iid_ole.c \
  		src/os_dos.h \
- 		src/os_msdos.c \
- 		src/os_msdos.h \
  		src/os_w32dll.c \
  		src/os_w32exe.c \
  		src/os_win32.c \
--- 319,324 ----
***************
*** 330,336 ****
  		src/os_win32.h \
  		src/proto/gui_w32.pro \
  		src/proto/if_ole.pro \
- 		src/proto/os_msdos.pro \
  		src/proto/os_win32.pro \
  		src/proto/os_mswin.pro \
  		src/testdir/Make_dos.mak \
--- 326,331 ----
***************
*** 345,353 ****
  		src/vimtbar.h \
  		src/xpm_w32.c \
  		src/xpm_w32.h \
- 		src/xxd/Make_bc3.mak \
  		src/xxd/Make_bc5.mak \
- 		src/xxd/Make_djg.mak \
  		src/xxd/Make_ming.mak \
  		src/xxd/Make_mvc.mak \
  		nsis/gvim.nsi \
--- 340,346 ----
*** ../vim-7.4.1398/src/Make_bc3.mak	2016-01-23 19:45:48.622931332 +0100
--- src/Make_bc3.mak	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,184 ****
- # Makefile for Borland C++ 3.1 or 4.0 to compile a 16 bit version of Vim.
- #
- # NOTE: THIS IS OLD AND PROBABLY NO LONGER WORKS.
- #
- # There are compilation options at the end of this file.
- #
- # Command line variables:
- # BOR		path to root of Borland C (E:\BORLANDC)
- # DEBUG		set to "yes" for debugging (no)
- # SPAWNO	path to the spawno library directory, empty if you do not have
- #		it; use 8.3 filenames! (C:\CC\SPAWN)
- 
- .AUTODEPEND
- 
- !ifndef BOR
- BOR = E:\BORLANDC
- !endif
- 
- !if ("$(DEBUG)" == "yes")
- DEBUG_FLAG = -v
- !else
- DEBUG_FLAG =
- !endif
- 
- CC = $(BOR)\bin\bcc.exe +VIM.CFG
- TLINK = $(BOR)\bin\tlink.exe
- 
- !ifndef SPAWNO
- SPAWNO = C:\CC\SPAWN
- !endif
- 
- !if ("$(SPAWNO)" == "")
- LIBPATH = $(BOR)\LIB
- INCLUDEPATH = $(BOR)\INCLUDE
- SPAWND =
- SPAWNL =
- !else
- LIBPATH = $(BOR)\LIB;$(SPAWNO)
- INCLUDEPATH = $(BOR)\INCLUDE;$(SPAWNO)
- SPAWND = ;SPAWNO
- SPAWNL = spawnl.lib
- !endif
- 
- 
- #		*Implicit Rules*
- #
- # use -v for debugging
- #
- .c.obj:
- 	$(CC) -c $(DEBUG_FLAG) {$< }
- 
- #		*List Macros*
- 
- 
- EXE_dependencies = \
- 	blowfish.obj \
- 	buffer.obj \
- 	charset.obj \
- 	crypt.obj \
- 	crypt_zip.obj \
- 	diff.obj \
- 	digraph.obj \
- 	edit.obj \
- 	eval.obj \
- 	ex_cmds.obj \
- 	ex_cmds2.obj \
- 	ex_docmd.obj \
- 	ex_eval.obj \
- 	ex_getln.obj \
- 	fileio.obj \
- 	fold.obj \
- 	getchar.obj \
- 	hardcopy.obj \
- 	hashtab.obj \
- 	json.obj \
- 	main.obj \
- 	mark.obj \
- 	memfile.obj \
- 	memline.obj \
- 	menu.obj \
- 	message.obj \
- 	misc1.obj \
- 	misc2.obj \
- 	move.obj \
- 	os_msdos.obj \
- 	normal.obj \
- 	ops.obj \
- 	option.obj \
- 	popupmnu.obj \
- 	quickfix.obj \
- 	regexp.obj \
- 	screen.obj \
- 	search.obj \
- 	sha256.obj \
- 	spell.obj \
- 	syntax.obj \
- 	tag.obj \
- 	term.obj \
- 	ui.obj \
- 	undo.obj \
- 	window.obj
- 
- all: vim.exe install.exe uninstal.exe xxd/xxd.exe
- 
- #		*Explicit Rules*
- 
- vim.exe: vim.cfg $(EXE_dependencies) version.c
- 	$(CC) $(DEBUG_FLAG) -c version.c
- 	$(TLINK) /x/c/L$(LIBPATH) $(DEBUG_FLAG) @&&|
- c0l.obj $(EXE_dependencies) version.obj
- vim
- 		# no map file
- $(SPAWNL) cl.lib
- |
- 
- install.exe: dosinst.c
- 	$(CC) -einstall $(DEBUG_FLAG) dosinst.c
- 
- uninstal.exe: uninstal.c
- 	$(CC) $(DEBUG_FLAG) uninstal.c
- 
- # This may fail for older make versions, building xxd will fail anyway then.
- xxd/xxd.exe: xxd/xxd.c
- 	cd xxd
- 	$(MAKE) -f Make_bc3.mak BOR=$(BOR) DEBUG=$(DEBUG)
- 	cd ..
- 
- # cleaning up: Delete all generated files
- clean:
- 	-del *.obj
- 	-del vim.exe
- 	-del vim.sym
- 	-del install.exe
- 	-del uninstal.exe
- 	-del xxd\*.obj
- 	-del xxd\xxd.exe
- 	-del vim.cfg
- 	-del testdir\*.out
- 
- # Individual File Dependencies (incomplete)
- ex_docmd.obj: ex_docmd.c ex_cmds.h
- 
- ex_eval.obj: ex_eval.c ex_cmds.h
- 
- main.obj: main.c globals.h option.h
- 
- term.obj: term.c term.h
- 
- version.obj: version.c version.h
- 
- 
- # Compiler Configuration File
- #
- # The following compile options can be changed for better machines.
- #	replace -1- with -2 to produce code for a 80286 or higher
- #	replace -1- with -3 to produce code for a 80386 or higher
- #	add -v for source debugging
- vim.cfg: Make_bc3.mak
- 	copy &&|
- -ml
- -1-
- -f-
- -C
- -N
- -O
- -Z
- -k-
- -d
- -h
- -vi-
- -H=VIM.SYM
- -w-par
- -weas
- -wpre
- -Iproto
- -I$(INCLUDEPATH)
- -L$(LIBPATH)
- -DMSDOS;FEAT_TINY$(SPAWND)
- | vim.cfg
- 
- test:
- 	cd testdir
- 	$(MAKE) -f Make_dos.mak small
- 	cd ..
--- 0 ----
*** ../vim-7.4.1398/src/Make_bc5.mak	2016-01-24 20:36:18.870082307 +0100
--- src/Make_bc5.mak	2016-02-23 14:40:59.380415122 +0100
***************
*** 7,12 ****
--- 7,13 ----
  #
  # Contributed by Ben Singer.
  # Updated 4/1997 by Ron Aaron
+ #	2016: removed support for 16 bit DOS
  #	6/1997 - added support for 16 bit DOS
  #	Note: this has been tested, and works, for BC5.  Your mileage may vary.
  #	Has been reported NOT to work with BC 4.52.  Maybe it can be fixed?
***************
*** 34,41 ****
  # name		value (default)
  #
  # BOR		path to root of Borland C install (c:\bc5)
! # LINK		name of the linker ($(BOR)\bin\ilink if OSTYPE is DOS16,
! #		$(BOR)\bin\ilink32 otherwise)
  # GUI		no or yes: set to yes if you want the GUI version (yes)
  # LUA     define to path to Lua dir to get Lua support (not defined)
  #   LUA_VER	  define to version of Lua being used (51)
--- 35,41 ----
  # name		value (default)
  #
  # BOR		path to root of Borland C install (c:\bc5)
! # LINK		name of the linker ($(BOR)\bin\ilink32)
  # GUI		no or yes: set to yes if you want the GUI version (yes)
  # LUA     define to path to Lua dir to get Lua support (not defined)
  #   LUA_VER	  define to version of Lua being used (51)
***************
*** 70,76 ****
  # GETTEXT	no or yes: set to yes for multi-language support (yes)
  # ICONV		no or yes: set to yes for dynamic iconv support (yes)
  # OLE		no or yes: set to yes to make OLE gvim (no)
- # OSTYPE	DOS16 or WIN32 (WIN32)
  # DEBUG		no or yes: set to yes if you wish a DEBUGging build (no)
  # CODEGUARD	no or yes: set to yes if you want to use CODEGUARD (no)
  # CPUNR		1 through 6: select -CPU argument to compile with (3)
--- 70,75 ----
***************
*** 78,89 ****
  # USEDLL	no or yes: set to yes to use the Runtime library DLL (no)
  #		For USEDLL=yes the cc3250.dll is required to run Vim.
  # VIMDLL	no or yes: create vim32.dll, and stub (g)vim.exe (no)
! # ALIGN		1, 2 or 4: Alignment to use (4 for Win32, 2 for DOS16)
  # FASTCALL	no or yes: set to yes to use register-based function protocol (yes)
  # OPTIMIZE	SPACE, SPEED, or MAXSPEED: type of optimization (MAXSPEED)
  # POSTSCRIPT	no or yes: set to yes for PostScript printing
! # FEATURES	TINY, SMALL, NORMAL, BIG or HUGE
! #		(BIG for WIN32, SMALL for DOS16)
  # WINVER	0x0400 or 0x0500: minimum Win32 version to support (0x0400)
  # CSCOPE	no or yes: include support for Cscope interface (yes)
  # NETBEANS	no or yes: include support for Netbeans interface; also
--- 77,87 ----
  # USEDLL	no or yes: set to yes to use the Runtime library DLL (no)
  #		For USEDLL=yes the cc3250.dll is required to run Vim.
  # VIMDLL	no or yes: create vim32.dll, and stub (g)vim.exe (no)
! # ALIGN		1, 2 or 4: Alignment to use (4 for Win32)
  # FASTCALL	no or yes: set to yes to use register-based function protocol (yes)
  # OPTIMIZE	SPACE, SPEED, or MAXSPEED: type of optimization (MAXSPEED)
  # POSTSCRIPT	no or yes: set to yes for PostScript printing
! # FEATURES	TINY, SMALL, NORMAL, BIG or HUGE (BIG for WIN32)
  # WINVER	0x0400 or 0x0500: minimum Win32 version to support (0x0400)
  # CSCOPE	no or yes: include support for Cscope interface (yes)
  # NETBEANS	no or yes: include support for Netbeans interface; also
***************
*** 99,106 ****
  BOR = c:\bc5
  !endif
  
! ### LINK: Name of the linker: tlink or ilink32 (this is below, depends on
! # $(OSTYPE)
  
  ### GUI: yes for GUI version, no for console version
  !if ("$(GUI)"=="")
--- 97,103 ----
  BOR = c:\bc5
  !endif
  
! ### LINK: Name of the linker: ilink32 (this is below)
  
  ### GUI: yes for GUI version, no for console version
  !if ("$(GUI)"=="")
***************
*** 166,177 ****
  ### OLE: no for normal gvim, yes for OLE-capable gvim (only works with GUI)
  #OLE = yes
  
- ### OSTYPE: DOS16 for Windows 3.1 version, WIN32 for Windows 95/98/NT/2000
- #   version
- !if ("$(OSTYPE)"=="")
- OSTYPE = WIN32
- !endif
- 
  ### DEBUG: Uncomment to make an executable for debugging
  # DEBUG = yes
  !if ("$(DEBUG)"=="yes")
--- 163,168 ----
***************
*** 208,221 ****
  ### VIMDLL: yes for a DLL version of VIM (NOT RECOMMENDED), no otherwise
  #VIMDLL = yes
  
! ### ALIGN: alignment you desire: (1,2 or 4: s/b 4 for Win32, 2 for DOS)
  !if ("$(ALIGN)"=="")
- !if ($(OSTYPE)==DOS16)
- ALIGN = 2
- !else
  ALIGN = 4
  !endif
- !endif
  
  ### FASTCALL: yes to use FASTCALL calling convention (RECOMMENDED!), no otherwise
  #   Incompatible when calling external functions (like MSVC-compiled DLLs), so
--- 199,208 ----
  ### VIMDLL: yes for a DLL version of VIM (NOT RECOMMENDED), no otherwise
  #VIMDLL = yes
  
! ### ALIGN: alignment you desire: (1,2 or 4: s/b 4 for Win32)
  !if ("$(ALIGN)"=="")
  ALIGN = 4
  !endif
  
  ### FASTCALL: yes to use FASTCALL calling convention (RECOMMENDED!), no otherwise
  #   Incompatible when calling external functions (like MSVC-compiled DLLs), so
***************
*** 239,251 ****
  OPTIMIZE = MAXSPEED
  !endif
  
! ### FEATURES: TINY, SMALL, NORMAL, BIG or HUGE (BIG for WIN32, SMALL for DOS16)
  !if ("$(FEATURES)"=="")
- ! if ($(OSTYPE)==DOS16)
- FEATURES = SMALL
- ! else
  FEATURES = BIG
- ! endif
  !endif
  
  ### POSTSCRIPT: uncomment this line if you want PostScript printing
--- 226,234 ----
  OPTIMIZE = MAXSPEED
  !endif
  
! ### FEATURES: TINY, SMALL, NORMAL, BIG or HUGE (BIG for WIN32)
  !if ("$(FEATURES)"=="")
  FEATURES = BIG
  !endif
  
  ### POSTSCRIPT: uncomment this line if you want PostScript printing
***************
*** 266,289 ****
  # Sanity checks for the above options:
  #
  
! !if ($(OSTYPE)==DOS16)
! !if (($(CPUNR)+0)>4)
! !error CPUNR Must be less than or equal to 4 for DOS16
! !endif
! 
! !if (($(ALIGN)+0)>2)
! !error ALIGN Must be less than or equal to 2 for DOS16
! !endif
! 
! !else	# not DOS16
! !if (($(CPUNR)+0)<3)
! !error CPUNR Must be greater or equal to 3 for WIN32
! !endif
! !endif
! 
! !if ($(OSTYPE)!=WIN32) && ($(OSTYPE)!=DOS16)
! !error Check the OSTYPE variable again: $(OSTYPE) is not supported!
! !endif
  
  #
  # Optimizations: change as desired (RECOMMENDATION: Don't change!):
--- 249,255 ----
  # Sanity checks for the above options:
  #
  
! OSTYPE = WIN32
  
  #
  # Optimizations: change as desired (RECOMMENDATION: Don't change!):
***************
*** 305,315 ****
  OPT = $(OPT) -vi-
  !endif
  !endif
- !if ($(OSTYPE)==DOS16)
- !undef GUI
- !undef VIMDLL
- !undef USEDLL
- !endif
  # shouldn't have to change:
  LIB = $(BOR)\lib
  INCLUDE = $(BOR)\include;.;proto
--- 271,276 ----
***************
*** 483,498 ****
  # for now, anyway: VIMDLL is only for the GUI version
  TARGET = vim.exe
  !endif
- !if ($(OSTYPE)==DOS16)
- DEFINES= -DFEAT_$(FEATURES) -DMSDOS
- EXETYPE=-ml
- STARTUPOBJ = c0l.obj
- LINK2 =
- !else
  EXETYPE=-WC
  STARTUPOBJ = c0x32.obj
  LINK2 = -ap -OS -o -P
- !endif
  RESFILE = vim.res
  !endif
  
--- 444,452 ----
***************
*** 545,560 ****
  ##### BASE COMPILER/TOOLS RULES #####
  MAKE = $(BOR)\bin\make
  CFLAGS = -w-aus -w-par -w-pch -w-ngu -w-csu -I$(INCLUDE)
- !if ($(OSTYPE)==DOS16)
- BRC =
- !if ("$(LINK)"=="")
- LINK	= $(BOR)\BIN\TLink
- !endif
- CC   = $(BOR)\BIN\Bcc
- LFLAGS	= -Tde -c -m -L$(LIB) $(DEBUG_FLAG) $(LINK2)
- LFLAGSDLL  =
- CFLAGS = $(CFLAGS) -H- $(HEADERS)
- !else
  BRC = $(BOR)\BIN\brc32
  !if ("$(LINK)"=="")
  LINK	= $(BOR)\BIN\ILink32
--- 499,504 ----
***************
*** 563,569 ****
  LFLAGS	= -OS -Tpe -c -m -L$(LIB) $(DEBUG_FLAG) $(LINK2)
  LFLAGSDLL  = -Tpd -c -m -L$(LIB) $(DEBUG_FLAG) $(LINK2)
  CFLAGS = $(CFLAGS) -d -RT- -k- -Oi $(HEADERS) -f-
- !endif
  
  CC1 = -c
  CC2 = -o
--- 507,512 ----
***************
*** 583,590 ****
  .cpp.obj:
  	$(CC) $(CCARG) $(CC1) $(CC2)$@ $*.cpp
  
- !if ($(OSTYPE)==DOS16)
- !else # win32:
  vimmain = \
  	$(OBJDIR)\os_w32exe.obj
  !if ("$(VIMDLL)"=="yes")
--- 526,531 ----
***************
*** 594,600 ****
  vimwinmain = \
  	$(OBJDIR)\os_w32exe.obj
  !endif
- !endif
  
  vimobj =  \
  	$(OBJDIR)\blowfish.obj \
--- 535,540 ----
***************
*** 720,732 ****
  	$(OBJDIR)\gui_w32.obj
  !endif
  
- !if ($(OSTYPE)==WIN32)
  vimobj = $(vimobj) \
  	$(OBJDIR)\os_win32.obj $(OBJDIR)\os_mswin.obj $(OBJDIR)\winclip.obj
- !elif ($(OSTYPE)==DOS16)
- vimobj = $(vimobj) \
- 	$(OBJDIR)\os_msdos.obj
- !endif
  # Blab what we are going to do:
  MSG = Compiling $(OSTYPE) $(TARGET) $(OLETARGET), with:
  !if ("$(GUI)"=="yes")
--- 660,667 ----
***************
*** 818,831 ****
  
  !message $(MSG)
  
- !if ($(OSTYPE)==DOS16)
- TARGETS = $(TARGET)
- !else
  !if ("$(VIMDLL)"=="yes")
  TARGETS = $(DLLTARGET)
  !endif
  TARGETS = $(TARGETS) $(TARGET)
- !endif
  
  # Targets:
  all: vim vimrun.exe install.exe xxd uninstal.exe GvimExt/gvimext.dll
--- 753,762 ----
***************
*** 851,868 ****
  	cd ..
  
  install.exe: dosinst.c $(OBJDIR)\bcc.cfg
- !if ($(OSTYPE)==WIN32)
  	$(CC) $(CCARG) -WC -DWIN32 -einstall dosinst.c
- !else
- 	$(CC) $(CCARG) -WC -einstall dosinst.c
- !endif
  
  uninstal.exe: uninstal.c $(OBJDIR)\bcc.cfg
- !if ($(OSTYPE)==WIN32)
  	$(CC) $(CCARG) -WC -DWIN32 -O2 -euninstal uninstal.c
- !else
- 	$(CC) $(CCARG) -WC -O2 -euninstal uninstal.c
- !endif
  
  clean:
  !if "$(OS)" == "Windows_NT"
--- 782,791 ----
***************
*** 923,932 ****
  	cg32.lib+
  !endif
  # $(OSTYPE)==WIN32 causes os_mswin.c compilation. FEAT_SHORTCUT in it needs OLE
- !if ("$(OLE)"=="yes" || $(OSTYPE)==WIN32)
  	ole2w32.lib +
- !endif
- !if ($(OSTYPE)==WIN32)
  	import32.lib+
  !ifdef LUA
  	$(LUA_LIB_FLAG)lua.lib+
--- 846,852 ----
***************
*** 955,963 ****
  	cw32.lib
  !endif
  	vim.def
- !else
- 	cl.lib
- !endif
  |
  
  !if ("$(VIMDLL)"=="yes")
--- 875,880 ----
***************
*** 974,987 ****
  	$(vimobj)
  !endif
  	$<,$*
- !if ($(OSTYPE)==WIN32)
  !if ("$(CODEGUARD)"=="yes")
  	cg32.lib+
  !endif
  # $(OSTYPE)==WIN32 causes os_mswin.c compilation. FEAT_SHORTCUT in it needs OLE
- !if ("$(OLE)"=="yes" || $(OSTYPE)==WIN32)
  	ole2w32.lib +
- !endif
  	import32.lib+
  !ifdef LUA
  	$(LUA_LIB_FLAG)lua.lib+
--- 891,901 ----
***************
*** 1011,1019 ****
  !endif
  
  	$(OBJDIR)\$(RESFILE)
- !else
- 	emu.lib + cl.lib
- !endif
  |
  
  test:
--- 925,930 ----
*** ../vim-7.4.1398/src/Make_djg.mak	2016-01-01 17:56:13.405342815 +0100
--- src/Make_djg.mak	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,112 ****
- #
- # Makefile for VIM on MSDOS, using DJGPP 2.0
- #
- # NOTE: THIS IS OLD AND PROBABLY NO LONGER WORKS.
- #
- 
- #>>>>> choose options:
- 
- ### See feature.h for a list of optionals.
- ### Any other defines can be included here.
- 
- DEFINES =
- 
- #>>>>> name of the compiler and linker, name of lib directory
- CC = gcc
- 
- #>>>>> end of choices
- ###########################################################################
- 
- INCL = vim.h globals.h option.h keymap.h macros.h ascii.h term.h os_msdos.h structs.h
- CFLAGS = -O2 -DMSDOS -Iproto $(DEFINES) -Wall -Dinterrupt= -Dfar= -DMAXMEM=512 -D_NAIVE_DOS_REGS
- 
- OBJ = \
- 	obj/blowfish.o \
- 	obj/buffer.o \
- 	obj/charset.o \
- 	obj/crypt.o \
- 	obj/crypt_zip.o \
- 	obj/diff.o \
- 	obj/digraph.o \
- 	obj/edit.o \
- 	obj/eval.o \
- 	obj/ex_cmds.o \
- 	obj/ex_cmds2.o \
- 	obj/ex_docmd.o \
- 	obj/ex_eval.o \
- 	obj/ex_getln.o \
- 	obj/fileio.o \
- 	obj/fold.o \
- 	obj/getchar.o \
- 	obj/hardcopy.o \
- 	obj/hashtab.o \
- 	obj/main.o \
- 	obj/mark.o \
- 	obj/memfile.o \
- 	obj/memline.o \
- 	obj/menu.o \
- 	obj/message.o \
- 	obj/misc1.o \
- 	obj/misc2.o \
- 	obj/move.o \
- 	obj/mbyte.o \
- 	obj/normal.o \
- 	obj/ops.o \
- 	obj/option.o \
- 	obj/os_msdos.o \
- 	obj/popupmnu.o \
- 	obj/quickfix.o \
- 	obj/regexp.o \
- 	obj/screen.o \
- 	obj/search.o \
- 	obj/sha256.o \
- 	obj/spell.o \
- 	obj/syntax.o \
- 	obj/tag.o \
- 	obj/term.o \
- 	obj/ui.o \
- 	obj/undo.o \
- 	obj/window.o \
- 	$(TERMLIB)
- 
- all: vim.exe install.exe uninstal.exe xxd/xxd.exe
- 
- # version.c is compiled each time, so that it sets the build time.
- vim.exe: obj $(OBJ) version.c version.h
- 	$(CC) $(CFLAGS) -s -o vim.exe version.c $(OBJ) -lpc
- 
- install.exe: dosinst.c
- 	$(CC) $(CFLAGS) -s -o install.exe dosinst.c -lpc
- 
- uninstal.exe: uninstal.c
- 	$(CC) $(CFLAGS) -s -o uninstal.exe uninstal.c -lpc
- 
- # This requires GNU make.
- xxd/xxd.exe: xxd/xxd.c
- 	$(MAKE) --directory=xxd -f Make_djg.mak
- 
- obj:
- 	mkdir obj
- 
- tags:
- 	command /c ctags *.c $(INCL) ex_cmds.h
- 
- clean:
- 	-del obj\*.o
- 	-rmdir obj
- 	-del vim.exe
- 	-del install.exe
- 	-del xxd\xxd.exe
- 	-del testdir\*.out
- 
- # This requires GNU make.
- test:
- 	$(MAKE) --directory=testdir -f Make_dos.mak
- 
- ###########################################################################
- 
- obj/%.o: %.c obj $(INCL)
- 	$(CC) -c $(CFLAGS) -o $@ $<
- 
- # Extra dependency (there are actually many more...)
- obj/ex_docmd.o:	ex_cmds.h
--- 0 ----
*** ../vim-7.4.1398/src/Makefile	2016-02-20 13:54:39.137147115 +0100
--- src/Makefile	2016-02-23 14:32:02.821973716 +0100
***************
*** 908,914 ****
  ### after changing this, you need to do "make reconfig".
  #CONF_TERM_LIB = --with-tlib=ncurses
  
! ### For GCC on MSDOS, the ".exe" suffix will be added.
  #EXEEXT = .exe
  #LNKEXT = .exe
  
--- 908,914 ----
  ### after changing this, you need to do "make reconfig".
  #CONF_TERM_LIB = --with-tlib=ncurses
  
! ### For GCC on MS-Windows, the ".exe" suffix will be added.
  #EXEEXT = .exe
  #LNKEXT = .exe
  
***************
*** 1715,1721 ****
  # Resources used for the Mac are in one directory.
  RSRC_DIR = os_mac_rsrc
  
! PRO_MANUAL = os_amiga.pro os_msdos.pro os_win32.pro \
  	os_mswin.pro winclip.pro os_beos.pro os_vms.pro $(PERL_PRO)
  
  # Default target is making the executable and tools
--- 1715,1721 ----
  # Resources used for the Mac are in one directory.
  RSRC_DIR = os_mac_rsrc
  
! PRO_MANUAL = os_amiga.pro os_win32.pro \
  	os_mswin.pro winclip.pro os_beos.pro os_vms.pro $(PERL_PRO)
  
  # Default target is making the executable and tools
***************
*** 1836,1842 ****
  # Generate function prototypes.  This is not needed to compile vim, but if
  # you want to use it, cproto is out there on the net somewhere -- Webb
  #
! # When generating os_amiga.pro, os_msdos.pro and os_win32.pro there will be a
  # few include files that can not be found, that's OK.
  
  proto: $(PRO_AUTO) $(PRO_MANUAL)
--- 1836,1842 ----
  # Generate function prototypes.  This is not needed to compile vim, but if
  # you want to use it, cproto is out there on the net somewhere -- Webb
  #
! # When generating os_amiga.pro and os_win32.pro there will be a
  # few include files that can not be found, that's OK.
  
  proto: $(PRO_AUTO) $(PRO_MANUAL)
***************
*** 1864,1873 ****
  	$(CPROTO) -DAMIGA -UHAVE_CONFIG_H -DBPTR=char* $< > proto/$@
  	echo "/* vim: set ft=c : */" >> proto/$@
  
- os_msdos.pro: os_msdos.c
- 	$(CPROTO) -DMSDOS -UHAVE_CONFIG_H $< > proto/$@
- 	echo "/* vim: set ft=c : */" >> proto/$@
- 
  os_win32.pro: os_win32.c
  	$(CPROTO) -DWIN32 -UHAVE_CONFIG_H $< > proto/$@
  	echo "/* vim: set ft=c : */" >> proto/$@
--- 1864,1869 ----
*** ../vim-7.4.1398/src/blowfish.c	2016-01-30 15:14:02.527449037 +0100
--- src/blowfish.c	2016-02-23 14:30:39.754832907 +0100
***************
*** 34,40 ****
      char_u   uc[8];
  } block8;
  
! #if defined(WIN3264) || defined(DOS32)
    /* MS-Windows is always little endian */
  #else
  # ifdef HAVE_CONFIG_H
--- 34,40 ----
      char_u   uc[8];
  } block8;
  
! #if defined(WIN3264)
    /* MS-Windows is always little endian */
  #else
  # ifdef HAVE_CONFIG_H
*** ../vim-7.4.1398/src/buffer.c	2016-01-30 15:14:02.531448995 +0100
--- src/buffer.c	2016-02-23 14:25:16.602175249 +0100
***************
*** 541,549 ****
  {
      buf->b_ml.ml_line_count = 1;
      unchanged(buf, TRUE);
- #ifndef SHORT_FNAME
      buf->b_shortname = FALSE;
- #endif
      buf->b_p_eol = TRUE;
      buf->b_start_eol = TRUE;
  #ifdef FEAT_MBYTE
--- 541,547 ----
***************
*** 2911,2919 ****
      }
  #endif
  
- #ifndef SHORT_FNAME
      buf->b_shortname = FALSE;
- #endif
  
      buf_name_changed(buf);
      return OK;
--- 2909,2915 ----
***************
*** 4480,4486 ****
  # ifdef BACKSLASH_IN_FILENAME
  	    || strstr((char *)fname, "\\\\") != NULL
  # endif
! # if defined(MSWIN) || defined(DJGPP)
  	    || vim_strchr(fname, '~') != NULL
  # endif
  	    )
--- 4476,4482 ----
  # ifdef BACKSLASH_IN_FILENAME
  	    || strstr((char *)fname, "\\\\") != NULL
  # endif
! # if defined(MSWIN)
  	    || vim_strchr(fname, '~') != NULL
  # endif
  	    )
*** ../vim-7.4.1398/src/diff.c	2016-01-30 15:14:02.535448954 +0100
--- src/diff.c	2016-02-23 13:43:50.443878013 +0100
***************
*** 29,35 ****
  
  static int diff_a_works = MAYBE; /* TRUE when "diff -a" works, FALSE when it
  				    doesn't work, MAYBE when not checked yet */
! #if defined(MSWIN) || defined(MSDOS)
  static int diff_bin_works = MAYBE; /* TRUE when "diff --binary" works, FALSE
  				      when it doesn't work, MAYBE when not
  				      checked yet */
--- 29,35 ----
  
  static int diff_a_works = MAYBE; /* TRUE when "diff -a" works, FALSE when it
  				    doesn't work, MAYBE when not checked yet */
! #if defined(MSWIN)
  static int diff_bin_works = MAYBE; /* TRUE when "diff --binary" works, FALSE
  				      when it doesn't work, MAYBE when not
  				      checked yet */
***************
*** 733,739 ****
  	    break;
  #endif
  
! #if defined(MSWIN) || defined(MSDOS)
  	/* If the "-a" argument works, also check if "--binary" works. */
  	if (ok && diff_a_works == MAYBE && diff_bin_works == MAYBE)
  	{
--- 733,739 ----
  	    break;
  #endif
  
! #if defined(MSWIN)
  	/* If the "-a" argument works, also check if "--binary" works. */
  	if (ok && diff_a_works == MAYBE && diff_bin_works == MAYBE)
  	{
***************
*** 764,770 ****
  	    EMSG(_("E810: Cannot read or write temp files"));
  	EMSG(_("E97: Cannot create diffs"));
  	diff_a_works = MAYBE;
! #if defined(MSWIN) || defined(MSDOS)
  	diff_bin_works = MAYBE;
  #endif
  	goto theend;
--- 764,770 ----
  	    EMSG(_("E810: Cannot read or write temp files"));
  	EMSG(_("E97: Cannot create diffs"));
  	diff_a_works = MAYBE;
! #if defined(MSWIN)
  	diff_bin_works = MAYBE;
  #endif
  	goto theend;
***************
*** 845,851 ****
  	     * non-zero when differences have been found. */
  	    vim_snprintf((char *)cmd, len, "diff %s%s%s%s%s %s",
  		    diff_a_works == FALSE ? "" : "-a ",
! #if defined(MSWIN) || defined(MSDOS)
  		    diff_bin_works == TRUE ? "--binary " : "",
  #else
  		    "",
--- 845,851 ----
  	     * non-zero when differences have been found. */
  	    vim_snprintf((char *)cmd, len, "diff %s%s%s%s%s %s",
  		    diff_a_works == FALSE ? "" : "-a ",
! #if defined(MSWIN)
  		    diff_bin_works == TRUE ? "--binary " : "",
  #else
  		    "",
*** ../vim-7.4.1398/src/digraph.c	2016-01-30 15:14:02.539448913 +0100
--- src/digraph.c	2016-02-23 13:44:33.543432707 +0100
***************
*** 39,112 ****
   * compilers cannot handle them (Amiga SAS/C is the most picky one).
   */
  static digr_T digraphdefault[] =
! #if defined(MSDOS)
! 	/*
! 	 * MSDOS digraphs.
! 	 */
!        {{'C', ',', 128},	/* ~@ XX */
! 	{'u', '"', 129},	/* Å */
! 	{'e', '\'', 130},	/* Ç */
! 	{'a', '^', 131},	/* É */
! 	{'a', '"', 132},	/* Ñ */
! 	{'a', '`', 133},	/* Ö */
! 	{'a', '@', 134},	/* Ü */
! 	{'c', ',', 135},	/* ~G XX */
! 	{'e', '^', 136},	/* ~H XX */
! 	{'e', '"', 137},	/* â */
! 	{'e', '`', 138},	/* ä */
! 	{'i', '"', 139},	/* ã */
! 	{'i', '^', 140},	/* å */
! 	{'i', '`', 141},	/* ç */
! 	{'A', '"', 142},	/* ~N XX */
! 	{'A', '@', 143},	/* è */
! 	{'E', '\'', 144},	/* ê */
! 	{'a', 'e', 145},	/* ë */
! 	{'A', 'E', 146},	/* í */
! 	{'o', '^', 147},	/* ì */
! 	{'o', '"', 148},	/* î */
! 	{'o', '`', 149},	/* ï */
! 	{'u', '^', 150},	/* ñ */
! 	{'u', '`', 151},	/* ó */
! 	{'y', '"', 152},	/* ò */
! 	{'O', '"', 153},	/* ô */
! 	{'U', '"', 154},	/* ö */
! 	{'c', '|', 155},	/* õ */
! 	{'$', '$', 156},	/* ú */
! 	{'Y', '-', 157},	/* ~] XX */
! 	{'P', 't', 158},	/* û */
! 	{'f', 'f', 159},	/* ü */
! 	{'a', '\'', 160},	/* † */
! 	{'i', '\'', 161},	/* ° */
! 	{'o', '\'', 162},	/* ¢ */
! 	{'u', '\'', 163},	/* x XX */
! 	{'n', '~', 164},	/* § */
! 	{'N', '~', 165},	/* • */
! 	{'a', 'a', 166},	/* ¶ */
! 	{'o', 'o', 167},	/* ß */
! 	{'~', '?', 168},	/* ® */
! 	{'-', 'a', 169},	/* © */
! 	{'a', '-', 170},	/* ™ */
! 	{'1', '2', 171},	/* ´ */
! 	{'1', '4', 172},	/* ¨ */
! 	{'~', '!', 173},	/* ≠ */
! 	{'<', '<', 174},	/* Æ */
! 	{'>', '>', 175},	/* Ø */
! 
! 	{'s', 's', 225},	/* · */
! 	{'j', 'u', 230},	/* Ê */
! 	{'o', '/', 237},	/* Ì */
! 	{'+', '-', 241},	/* Ò */
! 	{'>', '=', 242},	/* Ú */
! 	{'<', '=', 243},	/* Û */
! 	{':', '-', 246},	/* ˆ */
! 	{'~', '~', 247},	/* ˜ */
! 	{'~', 'o', 248},	/* ¯ */
! 	{'2', '2', 253},	/* ˝ */
! 	{NUL, NUL, NUL}
! 	};
! 
! #else	/* !MSDOS */
! # ifdef __MINT__
  
  	/*
  	 * ATARI digraphs
--- 39,45 ----
   * compilers cannot handle them (Amiga SAS/C is the most picky one).
   */
  static digr_T digraphdefault[] =
! #ifdef __MINT__
  
  	/*
  	 * ATARI digraphs
***************
*** 171,178 ****
  	{NUL, NUL, NUL}
  	};
  
! # else	/* !__MINT__ */
! #  ifdef HPUX_DIGRAPHS
  
  	/*
  	 * different HPUX digraphs
--- 104,111 ----
  	{NUL, NUL, NUL}
  	};
  
! #else	/* !__MINT__ */
! # ifdef HPUX_DIGRAPHS
  
  	/*
  	 * different HPUX digraphs
***************
*** 275,283 ****
  	{NUL, NUL, NUL}
  	};
  
! #  else	/* !HPUX_DIGRAPHS */
  
! #   ifdef EBCDIC
  
  	/*
  	 * EBCDIC - ISO digraphs
--- 208,216 ----
  	{NUL, NUL, NUL}
  	};
  
! # else	/* !HPUX_DIGRAPHS */
  
! #  ifdef EBCDIC
  
  	/*
  	 * EBCDIC - ISO digraphs
***************
*** 387,394 ****
  	{NUL, NUL, NUL}
  	};
  
! #   else
! #    if defined(MACOS) && !defined(FEAT_MBYTE)
  
  	/*
  	 * Macintosh digraphs
--- 320,327 ----
  	{NUL, NUL, NUL}
  	};
  
! #  else
! #   if defined(MACOS) && !defined(FEAT_MBYTE)
  
  	/*
  	 * Macintosh digraphs
***************
*** 516,524 ****
  	{NUL, NUL, NUL}
  	};
  
! #    else	/* !MACOS */
  
! #     ifdef OLD_DIGRAPHS
  
  	/*
  	 * digraphs compatible with Vim 5.x
--- 449,457 ----
  	{NUL, NUL, NUL}
  	};
  
! #   else	/* !MACOS */
  
! #    ifdef OLD_DIGRAPHS
  
  	/*
  	 * digraphs compatible with Vim 5.x
***************
*** 625,631 ****
  	{'y', '"', 255},	/* x XX */
  	{NUL, NUL, NUL}
  	};
! #     else /* OLD_DIGRAPHS */
  
  	/*
  	 * digraphs for Unicode from RFC1345
--- 558,564 ----
  	{'y', '"', 255},	/* x XX */
  	{NUL, NUL, NUL}
  	};
! #    else /* OLD_DIGRAPHS */
  
  	/*
  	 * digraphs for Unicode from RFC1345
***************
*** 2001,2013 ****
  	{NUL, NUL, NUL}
         };
  
! #     endif /* OLD_DIGRAPHS */
  
! #    endif /* Macintosh */
! #   endif /* EBCDIC */
! #  endif    /* !HPUX_DIGRAPHS */
! # endif	/* !__MINT__ */
! #endif	/* !MSDOS */
  
  /*
   * handle digraphs after typing a character
--- 1934,1945 ----
  	{NUL, NUL, NUL}
         };
  
! #    endif /* OLD_DIGRAPHS */
  
! #   endif /* Macintosh */
! #  endif /* EBCDIC */
! # endif    /* !HPUX_DIGRAPHS */
! #endif	/* !__MINT__ */
  
  /*
   * handle digraphs after typing a character
*** ../vim-7.4.1398/src/dosinst.h	2016-02-16 15:06:54.653635399 +0100
--- src/dosinst.h	2016-02-23 14:14:39.652762469 +0100
***************
*** 46,59 ****
  char *searchpath(char *name);
  #endif
  
! #if defined(DJGPP) || defined(UNIX_LINT)
  # include <unistd.h>
  # include <errno.h>
  #endif
  
  #include "version.h"
  
! #if defined(DJGPP) || defined(UNIX_LINT)
  # define vim_mkdir(x, y) mkdir((char *)(x), y)
  #else
  # if defined(WIN3264) && !defined(__BORLANDC__)
--- 46,59 ----
  char *searchpath(char *name);
  #endif
  
! #if defined(UNIX_LINT)
  # include <unistd.h>
  # include <errno.h>
  #endif
  
  #include "version.h"
  
! #if defined(UNIX_LINT)
  # define vim_mkdir(x, y) mkdir((char *)(x), y)
  #else
  # if defined(WIN3264) && !defined(__BORLANDC__)
***************
*** 63,71 ****
  # endif
  #endif
  
! #ifndef DJGPP
! # define sleep(n) Sleep((n) * 1000)
! #endif
  
  /* ---------------------------------------- */
  
--- 63,69 ----
  # endif
  #endif
  
! #define sleep(n) Sleep((n) * 1000)
  
  /* ---------------------------------------- */
  
***************
*** 423,431 ****
      char	*p;
  
      /* On WinNT, 'start' is a shell built-in for cmd.exe rather than an
!      * executable (start.exe) like in Win9x.  DJGPP, being a DOS program,
!      * is given the COMSPEC command.com by WinNT, so we have to find
!      * cmd.exe manually and use it. */
      cmd_path = searchpath_save("cmd.exe");
      if (cmd_path != NULL)
      {
--- 421,427 ----
      char	*p;
  
      /* On WinNT, 'start' is a shell built-in for cmd.exe rather than an
!      * executable (start.exe) like in Win9x. */
      cmd_path = searchpath_save("cmd.exe");
      if (cmd_path != NULL)
      {
***************
*** 640,653 ****
      static void
  do_inits(char **argv)
  {
- #ifdef DJGPP
-     /*
-      * Use Long File Names by default, if $LFN not set.
-      */
-     if (getenv("LFN") == NULL)
- 	putenv("LFN=y");
- #endif
- 
      /* Find out the full path of our executable. */
      if (my_fullpath(installdir, argv[0], BUFSIZE) == NULL)
      {
--- 636,641 ----
*** ../vim-7.4.1398/src/eval.c	2016-02-23 13:20:18.466462173 +0100
--- src/eval.c	2016-02-23 13:45:29.894850465 +0100
***************
*** 13503,13515 ****
  #ifdef __BEOS__
  	"beos",
  #endif
- #ifdef MSDOS
- # ifdef DJGPP
- 	"dos32",
- # else
- 	"dos16",
- # endif
- #endif
  #ifdef MACOS
  	"mac",
  #endif
--- 13503,13508 ----
*** ../vim-7.4.1398/src/ex_cmds.c	2016-02-06 15:29:34.784012360 +0100
--- src/ex_cmds.c	2016-02-23 14:25:37.437959753 +0100
***************
*** 1925,1938 ****
  #ifdef UNIX
  				    shortname,
  #else
! # ifdef SHORT_FNAME
! 				    TRUE,
! # else
! #  ifdef FEAT_GUI_W32
  				    gui_is_win32s(),
! #  else
  				    FALSE,
- #  endif
  # endif
  #endif
  				    fname,
--- 1925,1934 ----
  #ifdef UNIX
  				    shortname,
  #else
! # ifdef FEAT_GUI_W32
  				    gui_is_win32s(),
! # else
  				    FALSE,
  # endif
  #endif
  				    fname,
*** ../vim-7.4.1398/src/ex_cmds2.c	2016-02-22 23:25:20.056316277 +0100
--- src/ex_cmds2.c	2016-02-23 14:07:31.209192775 +0100
***************
*** 4256,4263 ****
  {
      char_u	*loc;
  
!     /* Obtain the locale value from the libraries.  For DJGPP this is
!      * redefined and it doesn't use the arguments. */
      loc = (char_u *)setlocale(what, NULL);
  
  # ifdef WIN32
--- 4256,4262 ----
  {
      char_u	*loc;
  
!     /* Obtain the locale value from the libraries. */
      loc = (char_u *)setlocale(what, NULL);
  
  # ifdef WIN32
*** ../vim-7.4.1398/src/ex_docmd.c	2016-01-31 20:24:09.970066843 +0100
--- src/ex_docmd.c	2016-02-23 13:45:44.606698454 +0100
***************
*** 3758,3764 ****
  
  	/* Check for environment variable */
  	if (*xp->xp_pattern == '$'
! #if defined(MSDOS) || defined(MSWIN)
  		|| *xp->xp_pattern == '%'
  #endif
  		)
--- 3758,3764 ----
  
  	/* Check for environment variable */
  	if (*xp->xp_pattern == '$'
! #if defined(MSWIN)
  		|| *xp->xp_pattern == '%'
  #endif
  		)
*** ../vim-7.4.1398/src/ex_getln.c	2016-02-16 15:06:54.661635316 +0100
--- src/ex_getln.c	2016-02-23 13:46:07.218464814 +0100
***************
*** 4918,4924 ****
  	if (*s == ' ')
  	    ++s;	/* Skip space used for absolute path name. */
  
! #if defined(MSDOS) || defined(MSWIN)
  	e = vim_strchr(s, ';');
  #else
  	e = vim_strchr(s, ':');
--- 4918,4924 ----
  	if (*s == ' ')
  	    ++s;	/* Skip space used for absolute path name. */
  
! #if defined(MSWIN)
  	e = vim_strchr(s, ';');
  #else
  	e = vim_strchr(s, ':');
***************
*** 5217,5223 ****
  	copy_option_part(&path, buf, MAXPATHL, ",");
  	if (STRLEN(buf) + STRLEN(file) + 2 < MAXPATHL)
  	{
! # if defined(MSWIN) || defined(MSDOS)
  	    /* Using the platform's path separator (\) makes vim incorrectly
  	     * treat it as an escape character, use '/' instead. */
  	    if (*buf != NUL && !after_pathsep(buf, buf + STRLEN(buf)))
--- 5217,5223 ----
  	copy_option_part(&path, buf, MAXPATHL, ",");
  	if (STRLEN(buf) + STRLEN(file) + 2 < MAXPATHL)
  	{
! # if defined(MSWIN)
  	    /* Using the platform's path separator (\) makes vim incorrectly
  	     * treat it as an escape character, use '/' instead. */
  	    if (*buf != NUL && !after_pathsep(buf, buf + STRLEN(buf)))
*** ../vim-7.4.1398/src/feature.h	2016-02-20 22:16:54.082901623 +0100
--- src/feature.h	2016-02-23 14:14:52.452630105 +0100
***************
*** 65,78 ****
  # if defined(UNIX) || defined(WIN3264) || defined(MACOS)
  #  define FEAT_HUGE
  # else
! #  if defined(MSWIN) || defined(DJGPP) || defined(VMS) || defined(MACOS) || defined(AMIGA)
  #   define FEAT_BIG
  #  else
! #   ifdef MSDOS
! #    define FEAT_SMALL
! #   else
! #    define FEAT_NORMAL
! #   endif
  #  endif
  # endif
  #endif
--- 65,74 ----
  # if defined(UNIX) || defined(WIN3264) || defined(MACOS)
  #  define FEAT_HUGE
  # else
! #  if defined(MSWIN) || defined(VMS) || defined(MACOS) || defined(AMIGA)
  #   define FEAT_BIG
  #  else
! #   define FEAT_NORMAL
  #  endif
  # endif
  #endif
***************
*** 467,473 ****
   *			and byte2line().
   *			Note: Required for Macintosh.
   */
! #if defined(FEAT_NORMAL) && !defined(MSDOS)
  # define FEAT_TITLE
  #endif
  
--- 463,469 ----
   *			and byte2line().
   *			Note: Required for Macintosh.
   */
! #if defined(FEAT_NORMAL)
  # define FEAT_TITLE
  #endif
  
***************
*** 541,547 ****
   *			with HAVE_TGETENT defined).
   *
   * (nothing)		Machine specific termcap entries will be included.
-  *			This is default for win16 to save static data.
   *
   * SOME_BUILTIN_TCAPS	Include most useful builtin termcap entries (used only
   *			with NO_BUILTIN_TCAPS not defined).
--- 537,542 ----
***************
*** 1060,1066 ****
  # ifdef FEAT_BIG
  #  define FEAT_MOUSE_SGR
  # endif
! # if defined(FEAT_NORMAL) && (defined(MSDOS) || defined(WIN3264))
  #  define DOS_MOUSE
  # endif
  # if defined(FEAT_NORMAL) && defined(__QNX__)
--- 1055,1061 ----
  # ifdef FEAT_BIG
  #  define FEAT_MOUSE_SGR
  # endif
! # if defined(FEAT_NORMAL) && defined(WIN3264)
  #  define DOS_MOUSE
  # endif
  # if defined(FEAT_NORMAL) && defined(__QNX__)
***************
*** 1176,1182 ****
   */
  #ifdef FEAT_NORMAL
  /* MS-DOS console and Win32 console can change cursor shape */
! # if defined(MSDOS) || (defined(WIN3264) && !defined(FEAT_GUI_W32))
  #  define MCH_CURSOR_SHAPE
  # endif
  # if defined(FEAT_GUI_W32) || defined(FEAT_GUI_MOTIF) \
--- 1171,1177 ----
   */
  #ifdef FEAT_NORMAL
  /* MS-DOS console and Win32 console can change cursor shape */
! # if defined(WIN3264) && !defined(FEAT_GUI_W32)
  #  define MCH_CURSOR_SHAPE
  # endif
  # if defined(FEAT_GUI_W32) || defined(FEAT_GUI_MOTIF) \
*** ../vim-7.4.1398/src/fileio.c	2016-02-16 15:06:54.661635316 +0100
--- src/fileio.c	2016-02-23 14:27:19.396905220 +0100
***************
*** 445,451 ****
  	    return FAIL;
  	}
  #endif
! #if defined(MSDOS) || defined(MSWIN)
  	/*
  	 * MS-Windows allows opening a device, but we will probably get stuck
  	 * trying to read it.
--- 445,451 ----
  	    return FAIL;
  	}
  #endif
! #if defined(MSWIN)
  	/*
  	 * MS-Windows allows opening a device, but we will probably get stuck
  	 * trying to read it.
***************
*** 521,532 ****
  
  /*
   * for UNIX: check readonly with perm and mch_access()
!  * for MSDOS and Amiga: check readonly by trying to open the file for writing
   */
      file_readonly = FALSE;
      if (read_stdin)
      {
! #if defined(MSDOS) || defined(MSWIN)
  	/* Force binary I/O on stdin to avoid CR-LF -> LF conversion. */
  	setmode(0, O_BINARY);
  #endif
--- 521,532 ----
  
  /*
   * for UNIX: check readonly with perm and mch_access()
!  * for Amiga: check readonly by trying to open the file for writing
   */
      file_readonly = FALSE;
      if (read_stdin)
      {
! #if defined(MSWIN)
  	/* Force binary I/O on stdin to avoid CR-LF -> LF conversion. */
  	setmode(0, O_BINARY);
  #endif
***************
*** 561,567 ****
  	msg_scroll = msg_save;
  #ifndef UNIX
  	/*
! 	 * On MSDOS and Amiga we can't open a directory, check here.
  	 */
  	isdir_f = (mch_isdir(fname));
  	perm = mch_getperm(fname);  /* check if the file exists */
--- 561,567 ----
  	msg_scroll = msg_save;
  #ifndef UNIX
  	/*
! 	 * On Amiga we can't open a directory, check here.
  	 */
  	isdir_f = (mch_isdir(fname));
  	perm = mch_getperm(fname);  /* check if the file exists */
***************
*** 3546,3552 ****
      }
      if (c == NODE_WRITABLE)
      {
! # if defined(MSDOS) || defined(MSWIN)
  	/* MS-Windows allows opening a device, but we will probably get stuck
  	 * trying to write to it.  */
  	if (!p_odev)
--- 3546,3552 ----
      }
      if (c == NODE_WRITABLE)
      {
! # if defined(MSWIN)
  	/* MS-Windows allows opening a device, but we will probably get stuck
  	 * trying to write to it.  */
  	if (!p_odev)
***************
*** 3791,3797 ****
  	    struct stat	st_new;
  	    char_u	*dirp;
  	    char_u	*rootname;
! #if defined(UNIX) && !defined(SHORT_FNAME)
  	    int		did_set_shortname;
  #endif
  
--- 3791,3797 ----
  	    struct stat	st_new;
  	    char_u	*dirp;
  	    char_u	*rootname;
! #if defined(UNIX)
  	    int		did_set_shortname;
  #endif
  
***************
*** 3834,3840 ****
  		    goto nobackup;
  		}
  
! #if defined(UNIX) && !defined(SHORT_FNAME)
  		did_set_shortname = FALSE;
  #endif
  
--- 3834,3840 ----
  		    goto nobackup;
  		}
  
! #if defined(UNIX)
  		did_set_shortname = FALSE;
  #endif
  
***************
*** 3846,3857 ****
  		    /*
  		     * Make backup file name.
  		     */
! 		    backup = buf_modname(
! #ifdef SHORT_FNAME
! 			    TRUE,
! #else
! 			    (buf->b_p_sn || buf->b_shortname),
! #endif
  						 rootname, backup_ext, FALSE);
  		    if (backup == NULL)
  		    {
--- 3846,3852 ----
  		    /*
  		     * Make backup file name.
  		     */
! 		    backup = buf_modname((buf->b_p_sn || buf->b_shortname),
  						 rootname, backup_ext, FALSE);
  		    if (backup == NULL)
  		    {
***************
*** 3878,3884 ****
  			{
  			    vim_free(backup);
  			    backup = NULL;	/* no backup file to delete */
- # ifndef SHORT_FNAME
  			    /*
  			     * may try again with 'shortname' set
  			     */
--- 3873,3878 ----
***************
*** 3891,3897 ****
  				/* setting shortname didn't help */
  			    if (did_set_shortname)
  				buf->b_shortname = FALSE;
- # endif
  			    break;
  			}
  #endif
--- 3885,3890 ----
***************
*** 4059,4070 ****
  		    backup = NULL;
  		else
  		{
! 		    backup = buf_modname(
! #ifdef SHORT_FNAME
! 			    TRUE,
! #else
! 			    (buf->b_p_sn || buf->b_shortname),
! #endif
  						 rootname, backup_ext, FALSE);
  		    vim_free(rootname);
  		}
--- 4052,4058 ----
  		    backup = NULL;
  		else
  		{
! 		    backup = buf_modname((buf->b_p_sn || buf->b_shortname),
  						 rootname, backup_ext, FALSE);
  		    vim_free(rootname);
  		}
***************
*** 4911,4922 ****
       */
      if (*p_pm && dobackup)
      {
! 	char *org = (char *)buf_modname(
! #ifdef SHORT_FNAME
! 					TRUE,
! #else
! 					(buf->b_p_sn || buf->b_shortname),
! #endif
  							  fname, p_pm, FALSE);
  
  	if (backup != NULL)
--- 4899,4905 ----
       */
      if (*p_pm && dobackup)
      {
! 	char *org = (char *)buf_modname((buf->b_p_sn || buf->b_shortname),
  							  fname, p_pm, FALSE);
  
  	if (backup != NULL)
***************
*** 5287,5293 ****
      static int
  time_differs(long t1, long t2)
  {
! #if defined(__linux__) || defined(MSDOS) || defined(MSWIN)
      /* On a FAT filesystem, esp. under Linux, there are only 5 bits to store
       * the seconds.  Since the roundoff is done when flushing the inode, the
       * time may change unexpectedly by one second!!! */
--- 5270,5276 ----
      static int
  time_differs(long t1, long t2)
  {
! #if defined(__linux__) || defined(MSWIN)
      /* On a FAT filesystem, esp. under Linux, there are only 5 bits to store
       * the seconds.  Since the roundoff is done when flushing the inode, the
       * time may change unexpectedly by one second!!! */
***************
*** 6030,6038 ****
      if (fnamencmp(dir_name, full_path, len) == 0)
      {
  	p = full_path + len;
! #if defined(MSDOS) || defined(MSWIN)
  	/*
! 	 * MSDOS: when a file is in the root directory, dir_name will end in a
  	 * slash, since C: by itself does not define a specific dir. In this
  	 * case p may already be correct. <negri>
  	 */
--- 6013,6021 ----
      if (fnamencmp(dir_name, full_path, len) == 0)
      {
  	p = full_path + len;
! #if defined(MSWIN)
  	/*
! 	 * MSWIN: when a file is in the root directory, dir_name will end in a
  	 * slash, since C: by itself does not define a specific dir. In this
  	 * case p may already be correct. <negri>
  	 */
***************
*** 6047,6053 ****
  #endif
  	}
      }
! #if defined(MSDOS) || defined(MSWIN)
      /*
       * When using a file in the current drive, remove the drive name:
       * "A:\dir\file" -> "\dir\file".  This helps when moving a session file on
--- 6030,6036 ----
  #endif
  	}
      }
! #if defined(MSWIN)
      /*
       * When using a file in the current drive, remove the drive name:
       * "A:\dir\file" -> "\dir\file".  This helps when moving a session file on
***************
*** 6163,6174 ****
      char_u *ext,
      int	    prepend_dot)	/* may prepend a '.' to file name */
  {
!     return buf_modname(
! #ifdef SHORT_FNAME
! 			TRUE,
! #else
! 			(curbuf->b_p_sn || curbuf->b_shortname),
! #endif
  						     fname, ext, prepend_dot);
  }
  
--- 6146,6152 ----
      char_u *ext,
      int	    prepend_dot)	/* may prepend a '.' to file name */
  {
!     return buf_modname((curbuf->b_p_sn || curbuf->b_shortname),
  						     fname, ext, prepend_dot);
  }
  
***************
*** 6207,6215 ****
  	    retval[fnamelen++] = PATHSEP;
  	    retval[fnamelen] = NUL;
  	}
- #ifndef SHORT_FNAME
  	prepend_dot = FALSE;	    /* nothing to prepend a dot to */
- #endif
      }
      else
      {
--- 6185,6191 ----
***************
*** 6235,6243 ****
  #ifdef USE_LONG_FNAME
  		    && (!USE_LONG_FNAME || shortname)
  #else
- # ifndef SHORT_FNAME
  		    && shortname
- # endif
  #endif
  								)
  	    if (*ptr == '.')	/* replace '.' by '_' */
--- 6211,6217 ----
***************
*** 6250,6259 ****
      }
  
      /* the file name has at most BASENAMELEN characters. */
- #ifndef SHORT_FNAME
      if (STRLEN(ptr) > (unsigned)BASENAMELEN)
  	ptr[BASENAMELEN] = '\0';
- #endif
  
      s = ptr + STRLEN(ptr);
  
--- 6224,6231 ----
***************
*** 6263,6271 ****
  #ifdef USE_LONG_FNAME
      if (!USE_LONG_FNAME || shortname)
  #else
- # ifndef SHORT_FNAME
      if (shortname)
- # endif
  #endif
      {
  	/*
--- 6235,6241 ----
***************
*** 6320,6326 ****
       */
      STRCPY(s, ext);
  
- #ifndef SHORT_FNAME
      /*
       * Prepend the dot.
       */
--- 6290,6295 ----
***************
*** 6333,6339 ****
  	STRMOVE(e + 1, e);
  	*e = '.';
      }
- #endif
  
      /*
       * Check that, after appending the extension, the file name is really
--- 6302,6307 ----
*** ../vim-7.4.1398/src/getchar.c	2016-02-10 22:23:02.256605792 +0100
--- src/getchar.c	2016-02-23 14:08:10.156790060 +0100
***************
*** 1677,1691 ****
  		c = CSI;
  #endif
  	}
- #ifdef MSDOS
- 	/*
- 	 * If K_NUL was typed, it is replaced by K_NUL, 3 in mch_inchar().
- 	 * Delete the 3 here.
- 	 */
- 	else if (c == K_NUL && vpeekc() == 3)
- 	    (void)vgetorpeek(TRUE);
- #endif
- 
  	/* a keypad or special function key was not mapped, use it like
  	 * its ASCII equivalent */
  	switch (c)
--- 1677,1682 ----
***************
*** 5241,5247 ****
  }
  #endif
  
! #if defined(MSDOS) || defined(MSWIN) || defined(MACOS)
  
  #define VIS_SEL	(VISUAL+SELECTMODE)	/* abbreviation */
  
--- 5232,5238 ----
  }
  #endif
  
! #if defined(MSWIN) || defined(MACOS)
  
  #define VIS_SEL	(VISUAL+SELECTMODE)	/* abbreviation */
  
***************
*** 5254,5260 ****
      int		mode;
  } initmappings[] =
  {
! #if defined(MSDOS) || defined(MSWIN)
  	/* Use the Windows (CUA) keybindings. */
  # ifdef FEAT_GUI
  	/* paste, copy and cut */
--- 5245,5251 ----
      int		mode;
  } initmappings[] =
  {
! #if defined(MSWIN)
  	/* Use the Windows (CUA) keybindings. */
  # ifdef FEAT_GUI
  	/* paste, copy and cut */
***************
*** 5274,5290 ****
  
  	/* paste, copy and cut */
  #  ifdef FEAT_CLIPBOARD
- #   ifdef DJGPP
- 	{(char_u *)"\316\122 \"*P", NORMAL},	    /* SHIFT-Insert is "*P */
- 	{(char_u *)"\316\122 \"-d\"*P", VIS_SEL},   /* SHIFT-Insert is "-d"*P */
- 	{(char_u *)"\316\122 \022\017*", INSERT},  /* SHIFT-Insert is ^R^O* */
- 	{(char_u *)"\316\222 \"*y", VIS_SEL},	    /* CTRL-Insert is "*y */
- #    if 0 /* Shift-Del produces the same code as Del */
- 	{(char_u *)"\316\123 \"*d", VIS_SEL},	    /* SHIFT-Del is "*d */
- #    endif
- 	{(char_u *)"\316\223 \"*d", VIS_SEL},	    /* CTRL-Del is "*d */
- 	{(char_u *)"\030 \"-d", VIS_SEL},	    /* CTRL-X is "-d */
- #   else
  	{(char_u *)"\316\324 \"*P", NORMAL},	    /* SHIFT-Insert is "*P */
  	{(char_u *)"\316\324 \"-d\"*P", VIS_SEL},   /* SHIFT-Insert is "-d"*P */
  	{(char_u *)"\316\324 \022\017*", INSERT},  /* SHIFT-Insert is ^R^O* */
--- 5265,5270 ----
***************
*** 5292,5298 ****
  	{(char_u *)"\316\327 \"*d", VIS_SEL},	    /* SHIFT-Del is "*d */
  	{(char_u *)"\316\330 \"*d", VIS_SEL},	    /* CTRL-Del is "*d */
  	{(char_u *)"\030 \"-d", VIS_SEL},	    /* CTRL-X is "-d */
- #   endif
  #  else
  	{(char_u *)"\316\324 P", NORMAL},	    /* SHIFT-Insert is P */
  	{(char_u *)"\316\324 \"-dP", VIS_SEL},	    /* SHIFT-Insert is "-dP */
--- 5272,5277 ----
***************
*** 5325,5331 ****
      void
  init_mappings(void)
  {
! #if defined(MSDOS) || defined(MSWIN) ||defined(MACOS)
      int		i;
  
      for (i = 0; i < (int)(sizeof(initmappings) / sizeof(struct initmap)); ++i)
--- 5304,5310 ----
      void
  init_mappings(void)
  {
! #if defined(MSWIN) ||defined(MACOS)
      int		i;
  
      for (i = 0; i < (int)(sizeof(initmappings) / sizeof(struct initmap)); ++i)
***************
*** 5333,5340 ****
  #endif
  }
  
! #if defined(MSDOS) || defined(MSWIN) \
! 	|| defined(FEAT_CMDWIN) || defined(MACOS) || defined(PROTO)
  /*
   * Add a mapping "map" for mode "mode".
   * Need to put string in allocated memory, because do_map() will modify it.
--- 5312,5318 ----
  #endif
  }
  
! #if defined(MSWIN) || defined(FEAT_CMDWIN) || defined(MACOS) || defined(PROTO)
  /*
   * Add a mapping "map" for mode "mode".
   * Need to put string in allocated memory, because do_map() will modify it.
*** ../vim-7.4.1398/src/globals.h	2016-02-10 22:23:02.256605792 +0100
--- src/globals.h	2016-02-23 14:03:21.471774938 +0100
***************
*** 19,25 ****
   */
  EXTERN long	Rows			/* nr of rows in the screen */
  #ifdef DO_INIT
! # if defined(MSDOS) || defined(WIN3264)
  			    = 25L
  # else
  			    = 24L
--- 19,25 ----
   */
  EXTERN long	Rows			/* nr of rows in the screen */
  #ifdef DO_INIT
! # if defined(WIN3264)
  			    = 25L
  # else
  			    = 24L
***************
*** 948,956 ****
  #endif
  
  EXTERN int	no_abbr INIT(= TRUE);	/* TRUE when no abbreviations loaded */
- #ifdef MSDOS
- EXTERN int	beep_count INIT(= 0);	/* nr of beeps since last char typed */
- #endif
  
  #ifdef USE_EXE_NAME
  EXTERN char_u	*exe_name;		/* the name of the executable */
--- 948,953 ----
*** ../vim-7.4.1398/src/macros.h	2016-02-21 19:14:36.679958696 +0100
--- src/macros.h	2016-02-23 14:03:59.079386105 +0100
***************
*** 226,232 ****
  #if defined(UNIX) || defined(VMS)  /* open in rw------- mode */
  # define mch_open_rw(n, f)	mch_open((n), (f), (mode_t)0600)
  #else
! # if defined(MSDOS) || defined(MSWIN)  /* open read/write */
  #  define mch_open_rw(n, f)	mch_open((n), (f), S_IREAD | S_IWRITE)
  # else
  #  define mch_open_rw(n, f)	mch_open((n), (f), 0)
--- 226,232 ----
  #if defined(UNIX) || defined(VMS)  /* open in rw------- mode */
  # define mch_open_rw(n, f)	mch_open((n), (f), (mode_t)0600)
  #else
! # if defined(MSWIN)  /* open read/write */
  #  define mch_open_rw(n, f)	mch_open((n), (f), S_IREAD | S_IWRITE)
  # else
  #  define mch_open_rw(n, f)	mch_open((n), (f), 0)
*** ../vim-7.4.1398/src/main.c	2016-02-21 23:01:47.437323432 +0100
--- src/main.c	2016-02-23 14:06:27.425852281 +0100
***************
*** 10,19 ****
  #define EXTERN
  #include "vim.h"
  
- #ifdef SPAWNO
- # include <spawno.h>		/* special MS-DOS swapping library */
- #endif
- 
  #ifdef __CYGWIN__
  # ifndef WIN32
  #  include <cygwin/version.h>
--- 10,15 ----
***************
*** 505,512 ****
  
      /*
       * mch_init() sets up the terminal (window) for use.  This must be
!      * done after resetting full_screen, otherwise it may move the cursor
!      * (MSDOS).
       * Note that we may use mch_exit() before mch_init()!
       */
      mch_init();
--- 501,507 ----
  
      /*
       * mch_init() sets up the terminal (window) for use.  This must be
!      * done after resetting full_screen, otherwise it may move the cursor.
       * Note that we may use mch_exit() before mch_init()!
       */
      mch_init();
***************
*** 710,719 ****
      }
  #endif
  
- #ifdef SPAWNO		/* special MSDOS swapping library */
-     init_SPAWNO("", SWAP_ANY);
- #endif
- 
  #ifdef FEAT_VIMINFO
      /*
       * Read in registers, history etc, but not marks, from the viminfo file.
--- 705,710 ----
*** ../vim-7.4.1398/src/mbyte.c	2016-02-16 15:06:54.665635275 +0100
--- src/mbyte.c	2016-02-23 13:50:08.199974634 +0100
***************
*** 6005,6011 ****
  }
  
  #if defined(FEAT_GUI) || defined(AMIGA) || defined(WIN3264) \
! 	|| defined(MSDOS) || defined(PROTO)
  /*
   * Do conversion on typed input characters in-place.
   * The input and output are not NUL terminated!
--- 6005,6011 ----
  }
  
  #if defined(FEAT_GUI) || defined(AMIGA) || defined(WIN3264) \
! 	|| defined(PROTO)
  /*
   * Do conversion on typed input characters in-place.
   * The input and output are not NUL terminated!
*** ../vim-7.4.1398/src/memfile.c	2016-02-07 15:13:56.081193256 +0100
--- src/memfile.c	2016-02-23 13:50:56.227478302 +0100
***************
*** 541,547 ****
  {
      int		status;
      bhdr_T	*hp;
! #if defined(SYNC_DUP_CLOSE) && !defined(MSDOS)
      int		fd;
  #endif
      int		got_int_save = got_int;
--- 541,547 ----
  {
      int		status;
      bhdr_T	*hp;
! #if defined(SYNC_DUP_CLOSE)
      int		fd;
  #endif
      int		got_int_save = got_int;
***************
*** 635,652 ****
  		status = FAIL;
  	}
  #endif
! #ifdef MSDOS
! 	if (_dos_commit(mfp->mf_fd))
! 	    status = FAIL;
! #else
! # ifdef SYNC_DUP_CLOSE
  	/*
  	 * Win32 is a bit more work: Duplicate the file handle and close it.
  	 * This should flush the file to disk.
  	 */
  	if ((fd = dup(mfp->mf_fd)) >= 0)
  	    close(fd);
- # endif
  #endif
  #ifdef AMIGA
  # if defined(__AROS__) || defined(__amigaos4__)
--- 635,647 ----
  		status = FAIL;
  	}
  #endif
! #ifdef SYNC_DUP_CLOSE
  	/*
  	 * Win32 is a bit more work: Duplicate the file handle and close it.
  	 * This should flush the file to disk.
  	 */
  	if ((fd = dup(mfp->mf_fd)) >= 0)
  	    close(fd);
  #endif
  #ifdef AMIGA
  # if defined(__AROS__) || defined(__amigaos4__)
***************
*** 1263,1269 ****
       * fname cannot be NameBuff, because it must have been allocated.
       */
      mf_set_ffname(mfp);
! #if defined(MSDOS) || defined(MSWIN)
      /*
       * A ":!cd e:xxx" may change the directory without us knowing, use the
       * full pathname always.  Careful: This frees fname!
--- 1258,1264 ----
       * fname cannot be NameBuff, because it must have been allocated.
       */
      mf_set_ffname(mfp);
! #if defined(MSWIN)
      /*
       * A ":!cd e:xxx" may change the directory without us knowing, use the
       * full pathname always.  Careful: This frees fname!
*** ../vim-7.4.1398/src/memline.c	2016-02-07 15:13:56.085193214 +0100
--- src/memline.c	2016-02-23 14:28:25.260224002 +0100
***************
*** 326,338 ****
      curwin->w_nrwidth_line_count = 0;
  #endif
  
- #if defined(MSDOS) && !defined(DJGPP)
-     /* for 16 bit MS-DOS create a swapfile now, because we run out of
-      * memory very quickly */
-     if (p_uc != 0)
- 	ml_open_file(buf);
- #endif
- 
  /*
   * fill block0 struct and write page 0
   */
--- 326,331 ----
***************
*** 641,647 ****
      memfile_T	*mfp;
      char_u	*fname;
      char_u	*dirp;
! #if defined(MSDOS) || defined(MSWIN)
      char_u	*p;
  #endif
  
--- 634,640 ----
      memfile_T	*mfp;
      char_u	*fname;
      char_u	*dirp;
! #if defined(MSWIN)
      char_u	*p;
  #endif
  
***************
*** 672,678 ****
  	if (fname == NULL)	    /* no file name found for this dir */
  	    continue;
  
! #if defined(MSDOS) || defined(MSWIN)
  	/*
  	 * Set full pathname for swap file now, because a ":!cd dir" may
  	 * change directory without us knowing it.
--- 665,671 ----
  	if (fname == NULL)	    /* no file name found for this dir */
  	    continue;
  
! #if defined(MSWIN)
  	/*
  	 * Set full pathname for swap file now, because a ":!cd dir" may
  	 * change directory without us knowing it.
***************
*** 704,710 ****
  	    vim_free(mfp->mf_fname);
  	    mfp->mf_fname = fname;
  	    vim_free(mfp->mf_ffname);
! #if defined(MSDOS) || defined(MSWIN)
  	    mfp->mf_ffname = NULL;  /* mf_fname is full pathname already */
  #else
  	    mf_set_ffname(mfp);
--- 697,703 ----
  	    vim_free(mfp->mf_fname);
  	    mfp->mf_fname = fname;
  	    vim_free(mfp->mf_ffname);
! #if defined(MSWIN)
  	    mfp->mf_ffname = NULL;  /* mf_fname is full pathname already */
  #else
  	    mf_set_ffname(mfp);
***************
*** 797,803 ****
  	    continue;
  	if (mf_open_file(mfp, fname) == OK)	/* consumes fname! */
  	{
! #if defined(MSDOS) || defined(MSWIN)
  	    /*
  	     * set full pathname for swap file now, because a ":!cd dir" may
  	     * change directory without us knowing it.
--- 790,796 ----
  	    continue;
  	if (mf_open_file(mfp, fname) == OK)	/* consumes fname! */
  	{
! #if defined(MSWIN)
  	    /*
  	     * set full pathname for swap file now, because a ":!cd dir" may
  	     * change directory without us knowing it.
***************
*** 986,992 ****
  	b0p->b0_fname[0] = NUL;
      else
      {
! #if defined(MSDOS) || defined(MSWIN) || defined(AMIGA)
  	/* Systems that cannot translate "~user" back into a path: copy the
  	 * file name unmodified.  Do use slashes instead of backslashes for
  	 * portability. */
--- 979,985 ----
  	b0p->b0_fname[0] = NUL;
      else
      {
! #if defined(MSWIN) || defined(AMIGA)
  	/* Systems that cannot translate "~user" back into a path: copy the
  	 * file name unmodified.  Do use slashes instead of backslashes for
  	 * portability. */
***************
*** 1280,1286 ****
      {
  	msg_start();
  	msg_outtrans_attr(mfp->mf_fname, attr | MSG_HIST);
! #if defined(MSDOS) || defined(MSWIN)
  	if (STRNCMP(b0p->b0_hname, "PC ", 3) == 0)
  	    MSG_PUTS_ATTR(_(" cannot be used with this version of Vim.\n"),
  							     attr | MSG_HIST);
--- 1273,1279 ----
      {
  	msg_start();
  	msg_outtrans_attr(mfp->mf_fname, attr | MSG_HIST);
! #if defined(MSWIN)
  	if (STRNCMP(b0p->b0_hname, "PC ", 3) == 0)
  	    MSG_PUTS_ATTR(_(" cannot be used with this version of Vim.\n"),
  							     attr | MSG_HIST);
***************
*** 2147,2153 ****
  
  		if (b0_magic_wrong(&b0))
  		{
! #if defined(MSDOS) || defined(MSWIN)
  		    if (STRNCMP(b0.b0_hname, "PC ", 3) == 0)
  			MSG_PUTS(_("\n         [not usable with this version of Vim]"));
  		    else
--- 2140,2146 ----
  
  		if (b0_magic_wrong(&b0))
  		{
! #if defined(MSWIN)
  		    if (STRNCMP(b0.b0_hname, "PC ", 3) == 0)
  			MSG_PUTS(_("\n         [not usable with this version of Vim]"));
  		    else
***************
*** 2172,2184 ****
  {
      int		num_names;
  
- #ifdef SHORT_FNAME
-     /*
-      * (MS-DOS) always short names
-      */
-     names[0] = modname(path, (char_u *)".sw?", FALSE);
-     num_names = 1;
- #else /* !SHORT_FNAME */
      /*
       * (Win32 and Win64) never short names, but do prepend a dot.
       * (Not MS-DOS or Win32 or Win64) maybe short name, maybe not: Try both.
--- 2165,2170 ----
***************
*** 2262,2269 ****
      curbuf->b_shortname = shortname;
  # endif
  
- #endif /* !SHORT_FNAME */
- 
      return num_names;
  }
  
--- 2248,2253 ----
***************
*** 3953,3963 ****
  #endif
  
      r = buf_modname(
- #ifdef SHORT_FNAME
- 	    TRUE,
- #else
  	    (buf->b_p_sn || buf->b_shortname),
- #endif
  	    fname_res,
  	    (char_u *)
  #if defined(VMS)
--- 3937,3943 ----
***************
*** 3965,3977 ****
  #else
  	    ".swp",
  #endif
- #ifdef SHORT_FNAME		/* always 8.3 file name */
- 	    FALSE
- #else
  	    /* Prepend a '.' to the swap file name for the current directory. */
! 	    dir_name[0] == '.' && dir_name[1] == NUL
! #endif
! 	       );
      if (r == NULL)	    /* out of memory */
  	return NULL;
  
--- 3945,3952 ----
  #else
  	    ".swp",
  #endif
  	    /* Prepend a '.' to the swap file name for the current directory. */
! 	    dir_name[0] == '.' && dir_name[1] == NUL);
      if (r == NULL)	    /* out of memory */
  	return NULL;
  
***************
*** 4152,4163 ****
  #ifdef AMIGA
      BPTR	fh;
  #endif
- #ifndef SHORT_FNAME
      int		r;
- #endif
      char_u	*buf_fname = buf->b_fname;
  
! #if !defined(SHORT_FNAME) && !defined(UNIX)
  # define CREATE_DUMMY_FILE
      FILE	*dummyfd = NULL;
  
--- 4127,4136 ----
  #ifdef AMIGA
      BPTR	fh;
  #endif
      int		r;
      char_u	*buf_fname = buf->b_fname;
  
! #if !defined(UNIX)
  # define CREATE_DUMMY_FILE
      FILE	*dummyfd = NULL;
  
***************
*** 4217,4223 ****
  	    fname = NULL;
  	    break;
  	}
! #if defined(UNIX) && !defined(SHORT_FNAME)
  /*
   * Some systems have a MS-DOS compatible filesystem that use 8.3 character
   * file names. If this is the first try and the swap file name does not fit in
--- 4190,4196 ----
  	    fname = NULL;
  	    break;
  	}
! #if defined(UNIX)
  /*
   * Some systems have a MS-DOS compatible filesystem that use 8.3 character
   * file names. If this is the first try and the swap file name does not fit in
***************
*** 4356,4362 ****
  	 */
  	if (fname[n - 2] == 'w' && fname[n - 1] == 'p')	/* first try */
  	{
- #ifndef SHORT_FNAME
  	    /*
  	     * on MS-DOS compatible filesystems (e.g. messydos) file.doc.swp
  	     * and file.doc are the same file. To guess if this problem is
--- 4329,4334 ----
***************
*** 4379,4385 ****
  		    continue;	    /* try again with '.' replaced with '_' */
  		}
  	    }
- #endif
  	    /*
  	     * If we get here the ".swp" file really exists.
  	     * Give an error message, unless recovering, no file name, we are
--- 4351,4356 ----
*** ../vim-7.4.1398/src/misc1.c	2016-02-20 22:16:54.082901623 +0100
--- src/misc1.c	2016-02-23 14:09:20.596061712 +0100
***************
*** 3676,3703 ****
  		    && !(gui.in_use && gui.starting)
  #endif
  		    )
- 	    {
  		out_str(T_VB);
- 	    }
  	    else
- 	    {
- #ifdef MSDOS
- 		/*
- 		 * The number of beeps outputted is reduced to avoid having to
- 		 * wait for all the beeps to finish. This is only a problem on
- 		 * systems where the beeps don't overlap.
- 		 */
- 		if (beep_count == 0 || beep_count == 10)
- 		{
- 		    out_char(BELL);
- 		    beep_count = 1;
- 		}
- 		else
- 		    ++beep_count;
- #else
  		out_char(BELL);
- #endif
- 	    }
  	}
  
  	/* When 'verbose' is set and we are sourcing a script or executing a
--- 3676,3684 ----
***************
*** 3811,3817 ****
  # endif
  #endif
  
! #if defined(MSDOS) || defined(MSWIN)
      /*
       * Default home dir is C:/
       * Best assumption we can make in such a situation.
--- 3792,3798 ----
  # endif
  #endif
  
! #if defined(MSWIN)
      /*
       * Default home dir is C:/
       * Best assumption we can make in such a situation.
***************
*** 3947,3953 ****
  		    && at_start
  #endif
  	   )
! #if defined(MSDOS) || defined(MSWIN)
  		|| *src == '%'
  #endif
  		|| (*src == '~' && at_start))
--- 3928,3934 ----
  		    && at_start
  #endif
  	   )
! #if defined(MSWIN)
  		|| *src == '%'
  #endif
  		|| (*src == '~' && at_start))
***************
*** 3976,3982 ****
  #endif
  		{
  		    while (c-- > 0 && *tail != NUL && ((vim_isIDc(*tail))
! #if defined(MSDOS) || defined(MSWIN)
  			    || (*src == '%' && *tail != '%')
  #endif
  			    ))
--- 3957,3963 ----
  #endif
  		{
  		    while (c-- > 0 && *tail != NUL && ((vim_isIDc(*tail))
! #if defined(MSWIN)
  			    || (*src == '%' && *tail != '%')
  #endif
  			    ))
***************
*** 3985,3991 ****
  		    }
  		}
  
! #if defined(MSDOS) || defined(MSWIN) || defined(UNIX)
  # ifdef UNIX
  		if (src[1] == '{' && *tail != '}')
  # else
--- 3966,3972 ----
  		    }
  		}
  
! #if defined(MSWIN) || defined(UNIX)
  # ifdef UNIX
  		if (src[1] == '{' && *tail != '}')
  # else
***************
*** 4003,4009 ****
  #endif
  		    *var = NUL;
  		    var = vim_getenv(dst, &mustfree);
! #if defined(MSDOS) || defined(MSWIN) || defined(UNIX)
  		}
  #endif
  	    }
--- 3984,3990 ----
  #endif
  		    *var = NUL;
  		    var = vim_getenv(dst, &mustfree);
! #if defined(MSWIN) || defined(UNIX)
  		}
  #endif
  	    }
***************
*** 4194,4200 ****
      char_u	*pend;
      int		vimruntime;
  
! #if defined(MSDOS) || defined(MSWIN)
      /* use "C:/" when $HOME is not set */
      if (STRCMP(name, "HOME") == 0)
  	return homedir;
--- 4175,4181 ----
      char_u	*pend;
      int		vimruntime;
  
! #if defined(MSWIN)
      /* use "C:/" when $HOME is not set */
      if (STRCMP(name, "HOME") == 0)
  	return homedir;
***************
*** 4932,4938 ****
  {
      char_u  *retval;
  
! #if defined(MSDOS) || defined(MSWIN)
      /* may skip "c:" */
      if (isalpha(path[0]) && path[1] == ':')
  	retval = path + 2;
--- 4913,4919 ----
  {
      char_u  *retval;
  
! #if defined(MSWIN)
      /* may skip "c:" */
      if (isalpha(path[0]) && path[1] == ':')
  	retval = path + 2;
***************
*** 9734,9746 ****
  static int expand_backtick(garray_T *gap, char_u *pat, int flags);
  # endif
  
! # if defined(MSDOS) || defined(WIN3264)
  /*
   * File name expansion code for MS-DOS, Win16 and Win32.  It's here because
   * it's shared between these systems.
   */
! # if defined(DJGPP) || defined(PROTO)
! #  define _cdecl	    /* DJGPP doesn't have this */
  # else
  #  ifdef __BORLANDC__
  #   define _cdecl _RTLENTRYF
--- 9715,9727 ----
  static int expand_backtick(garray_T *gap, char_u *pat, int flags);
  # endif
  
! # if defined(WIN3264)
  /*
   * File name expansion code for MS-DOS, Win16 and Win32.  It's here because
   * it's shared between these systems.
   */
! # if defined(PROTO)
! #  define _cdecl
  # else
  #  ifdef __BORLANDC__
  #   define _cdecl _RTLENTRYF
***************
*** 9762,9775 ****
      char_u *d,
      char_u *s)
  {
! #  ifdef DJGPP
!     if (USE_LONG_FNAME)	    /* don't lower case on Windows 95/NT systems */
! 	while (*s)
! 	    *d++ = *s++;
!     else
! #  endif
! 	while (*s)
! 	    *d++ = TOLOWER_LOC(*s++);
      *d = NUL;
  }
  # endif
--- 9743,9750 ----
      char_u *d,
      char_u *s)
  {
!     while (*s)
! 	*d++ = TOLOWER_LOC(*s++);
      *d = NUL;
  }
  # endif
***************
*** 10078,10084 ****
  {
      return dos_expandpath(gap, path, 0, flags, FALSE);
  }
! # endif /* MSDOS || WIN3264 */
  
  #if (defined(UNIX) && !defined(VMS)) || defined(USE_UNIXFILENAME) \
  	|| defined(PROTO)
--- 10053,10059 ----
  {
      return dos_expandpath(gap, path, 0, flags, FALSE);
  }
! # endif /* WIN3264 */
  
  #if (defined(UNIX) && !defined(VMS)) || defined(USE_UNIXFILENAME) \
  	|| defined(PROTO)
***************
*** 10444,10450 ****
  	if (ga_grow(gap, 1) == FAIL)
  	    break;
  
! # if defined(MSWIN) || defined(MSDOS)
  	/* Avoid the path ending in a backslash, it fails when a comma is
  	 * appended. */
  	len = (int)STRLEN(buf);
--- 10419,10425 ----
  	if (ga_grow(gap, 1) == FAIL)
  	    break;
  
! # if defined(MSWIN)
  	/* Avoid the path ending in a backslash, it fails when a comma is
  	 * appended. */
  	len = (int)STRLEN(buf);
***************
*** 10482,10488 ****
  	int j = 0;
  
  	while ((fname[j] == path_part[i][j]
! # if defined(MSWIN) || defined(MSDOS)
  		|| (vim_ispathsep(fname[j]) && vim_ispathsep(path_part[i][j]))
  #endif
  			     ) && fname[j] != NUL && path_part[i][j] != NUL)
--- 10457,10463 ----
  	int j = 0;
  
  	while ((fname[j] == path_part[i][j]
! # if defined(MSWIN)
  		|| (vim_ispathsep(fname[j]) && vim_ispathsep(path_part[i][j]))
  #endif
  			     ) && fname[j] != NUL && path_part[i][j] != NUL)
***************
*** 10603,10609 ****
  	     */
  	    short_name = shorten_fname(path, curdir);
  	    if (short_name != NULL && short_name > path + 1
! #if defined(MSWIN) || defined(MSDOS)
  		    /* On windows,
  		     *	    shorten_fname("c:\a\a.txt", "c:\a\b")
  		     * returns "\a\a.txt", which is not really the short
--- 10578,10584 ----
  	     */
  	    short_name = shorten_fname(path, curdir);
  	    if (short_name != NULL && short_name > path + 1
! #if defined(MSWIN)
  		    /* On windows,
  		     *	    shorten_fname("c:\a\a.txt", "c:\a\b")
  		     * returns "\a\a.txt", which is not really the short
***************
*** 10743,10749 ****
  	if (*p == '\\' && p[1] != NUL)
  	    ++p;
  	else if (vim_strchr((char_u *)
! #if defined(MSDOS) || defined(MSWIN)
  				    "$%"
  #else
  				    "$"
--- 10718,10724 ----
  	if (*p == '\\' && p[1] != NUL)
  	    ++p;
  	else if (vim_strchr((char_u *)
! #if defined(MSWIN)
  				    "$%"
  #else
  				    "$"
*** ../vim-7.4.1398/src/misc2.c	2016-02-21 19:14:36.679958696 +0100
--- src/misc2.c	2016-02-23 14:16:56.707345158 +0100
***************
*** 805,816 ****
   * Some memory is reserved for error messages and for being able to
   * call mf_release_all(), which needs some memory for mf_trans_add().
   */
! #if defined(MSDOS) && !defined(DJGPP)
! # define SMALL_MEM
! # define KEEP_ROOM 8192L
! #else
! # define KEEP_ROOM (2 * 8192L)
! #endif
  #define KEEP_ROOM_KB (KEEP_ROOM / 1024L)
  
  /*
--- 805,811 ----
   * Some memory is reserved for error messages and for being able to
   * call mf_release_all(), which needs some memory for mf_trans_add().
   */
! #define KEEP_ROOM (2 * 8192L)
  #define KEEP_ROOM_KB (KEEP_ROOM / 1024L)
  
  /*
***************
*** 892,898 ****
      char_u	*p;		    /* pointer to new storage space */
      static int	releasing = FALSE;  /* don't do mf_release_all() recursive */
      int		try_again;
! #if defined(HAVE_AVAIL_MEM) && !defined(SMALL_MEM)
      static long_u allocated = 0;    /* allocated since last avail check */
  #endif
  
--- 887,893 ----
      char_u	*p;		    /* pointer to new storage space */
      static int	releasing = FALSE;  /* don't do mf_release_all() recursive */
      int		try_again;
! #if defined(HAVE_AVAIL_MEM)
      static long_u allocated = 0;    /* allocated since last avail check */
  #endif
  
***************
*** 909,920 ****
      mem_pre_alloc_l(&size);
  #endif
  
- #if defined(MSDOS) && !defined(DJGPP)
-     if (size >= 0xfff0)		/* in MSDOS we can't deal with >64K blocks */
- 	p = NULL;
-     else
- #endif
- 
      /*
       * Loop when out of memory: Try to release some memfile blocks and
       * if some blocks are released call malloc again.
--- 904,909 ----
***************
*** 934,947 ****
  	    /* 1. No check for available memory: Just return. */
  	    goto theend;
  #else
- # ifndef SMALL_MEM
  	    /* 2. Slow check for available memory: call mch_avail_mem() after
  	     *    allocating (KEEP_ROOM / 2) amount of memory. */
  	    allocated += size;
  	    if (allocated < KEEP_ROOM / 2)
  		goto theend;
  	    allocated = 0;
! # endif
  	    /* 3. check for available memory: call mch_avail_mem() */
  	    if (mch_avail_mem(TRUE) < KEEP_ROOM_KB && !releasing)
  	    {
--- 923,935 ----
  	    /* 1. No check for available memory: Just return. */
  	    goto theend;
  #else
  	    /* 2. Slow check for available memory: call mch_avail_mem() after
  	     *    allocating (KEEP_ROOM / 2) amount of memory. */
  	    allocated += size;
  	    if (allocated < KEEP_ROOM / 2)
  		goto theend;
  	    allocated = 0;
! 
  	    /* 3. check for available memory: call mch_avail_mem() */
  	    if (mch_avail_mem(TRUE) < KEEP_ROOM_KB && !releasing)
  	    {
***************
*** 5453,5459 ****
      if (vim_isAbsName(ff_file_to_find)
  	    /* "..", "../path", "." and "./path": don't use the path_option */
  	    || rel_to_curdir
! #if defined(MSWIN) || defined(MSDOS)
  	    /* handle "\tmp" as absolute path */
  	    || vim_ispathsep(ff_file_to_find[0])
  	    /* handle "c:name" as absolute path */
--- 5441,5447 ----
      if (vim_isAbsName(ff_file_to_find)
  	    /* "..", "../path", "." and "./path": don't use the path_option */
  	    || rel_to_curdir
! #if defined(MSWIN)
  	    /* handle "\tmp" as absolute path */
  	    || vim_ispathsep(ff_file_to_find[0])
  	    /* handle "c:name" as absolute path */
***************
*** 5507,5524 ****
  		buf = suffixes;
  		for (;;)
  		{
! 		    if (
! #ifdef DJGPP
! 			    /* "C:" by itself will fail for mch_getperm(),
! 			     * assume it's always valid. */
! 			    (find_what != FINDFILE_FILE && NameBuff[0] != NUL
! 				  && NameBuff[1] == ':'
! 				  && NameBuff[2] == NUL) ||
! #endif
! 			    (mch_getperm(NameBuff) >= 0
  			     && (find_what == FINDFILE_BOTH
  				 || ((find_what == FINDFILE_DIR)
! 						    == mch_isdir(NameBuff)))))
  		    {
  			file_name = vim_strsave(NameBuff);
  			goto theend;
--- 5495,5504 ----
  		buf = suffixes;
  		for (;;)
  		{
! 		    if (mch_getperm(NameBuff) >= 0
  			     && (find_what == FINDFILE_BOTH
  				 || ((find_what == FINDFILE_DIR)
! 						    == mch_isdir(NameBuff))))
  		    {
  			file_name = vim_strsave(NameBuff);
  			goto theend;
*** ../vim-7.4.1398/src/netbeans.c	2016-02-22 23:13:28.639798334 +0100
--- src/netbeans.c	2016-02-23 13:54:41.089154326 +0100
***************
*** 1432,1438 ****
  		if (buf_was_empty)
  		{
  		    if (ff_detected == EOL_UNKNOWN)
! #if defined(MSDOS) || defined(MSWIN)
  			ff_detected = EOL_DOS;
  #else
  			ff_detected = EOL_UNIX;
--- 1432,1438 ----
  		if (buf_was_empty)
  		{
  		    if (ff_detected == EOL_UNKNOWN)
! #if defined(MSWIN)
  			ff_detected = EOL_DOS;
  #else
  			ff_detected = EOL_UNIX;
*** ../vim-7.4.1398/src/option.c	2016-02-21 23:01:47.441323390 +0100
--- src/option.c	2016-02-23 14:29:03.895824393 +0100
***************
*** 155,163 ****
  #ifdef FEAT_SMARTINDENT
  # define PV_SI		OPT_BUF(BV_SI)
  #endif
! #ifndef SHORT_FNAME
! # define PV_SN		OPT_BUF(BV_SN)
! #endif
  #ifdef FEAT_SYN_HL
  # define PV_SMC		OPT_BUF(BV_SMC)
  # define PV_SYN		OPT_BUF(BV_SYN)
--- 155,161 ----
  #ifdef FEAT_SMARTINDENT
  # define PV_SI		OPT_BUF(BV_SI)
  #endif
! #define PV_SN		OPT_BUF(BV_SN)
  #ifdef FEAT_SYN_HL
  # define PV_SMC		OPT_BUF(BV_SMC)
  # define PV_SYN		OPT_BUF(BV_SYN)
***************
*** 352,360 ****
  #ifdef FEAT_SMARTINDENT
  static int	p_si;
  #endif
- #ifndef SHORT_FNAME
  static int	p_sn;
- #endif
  static long	p_sts;
  #if defined(FEAT_SEARCHPATH)
  static char_u	*p_sua;
--- 350,356 ----
***************
*** 464,470 ****
  
  /* 'isprint' for latin1 is also used for MS-Windows cp1252, where 0x80 is used
   * for the currency sign. */
! #if defined(MSDOS) || defined(MSWIN)
  # define ISP_LATIN1 (char_u *)"@,~-255"
  #else
  # define ISP_LATIN1 (char_u *)"@,161-255"
--- 460,466 ----
  
  /* 'isprint' for latin1 is also used for MS-Windows cp1252, where 0x80 is used
   * for the currency sign. */
! #if defined(MSWIN)
  # define ISP_LATIN1 (char_u *)"@,~-255"
  #else
  # define ISP_LATIN1 (char_u *)"@,161-255"
***************
*** 497,503 ****
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {
! #if (defined(MSDOS) || defined(WIN3264)) && !defined(FEAT_GUI_W32)
  			    (char_u *)128L,
  #else
  			    (char_u *)224L,
--- 493,499 ----
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {
! #if (defined(WIN3264)) && !defined(FEAT_GUI_W32)
  			    (char_u *)128L,
  #else
  			    (char_u *)224L,
***************
*** 572,578 ****
      {"background",  "bg",   P_STRING|P_VI_DEF|P_RCLR,
  			    (char_u *)&p_bg, PV_NONE,
  			    {
! #if (defined(MSDOS) || defined(WIN3264)) && !defined(FEAT_GUI)
  			    (char_u *)"dark",
  #else
  			    (char_u *)"light",
--- 568,574 ----
      {"background",  "bg",   P_STRING|P_VI_DEF|P_RCLR,
  			    (char_u *)&p_bg, PV_NONE,
  			    {
! #if (defined(WIN3264)) && !defined(FEAT_GUI)
  			    (char_u *)"dark",
  #else
  			    (char_u *)"light",
***************
*** 637,647 ****
  			    (char_u *)&p_bin, PV_BIN,
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"bioskey",	    "biosk",P_BOOL|P_VI_DEF,
- #ifdef MSDOS
- 			    (char_u *)&p_biosk, PV_NONE,
- #else
  			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"bomb",	    NULL,   P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
  #ifdef FEAT_MBYTE
--- 633,639 ----
***************
*** 889,899 ****
  #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"conskey",	    "consk",P_BOOL|P_VI_DEF,
- #ifdef MSDOS
- 			    (char_u *)&p_consk, PV_NONE,
- #else
  			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"copyindent",  "ci",   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_ci, PV_CI,
--- 881,887 ----
***************
*** 1317,1323 ****
  			    {
  # ifdef FEAT_GUI
  				(char_u *)"n-v-c:block-Cursor/lCursor,ve:ver35-Cursor,o:hor50-Cursor,i-ci:ver25-Cursor/lCursor,r-cr:hor20-Cursor/lCursor,sm:block-Cursor-blinkwait175-blinkoff150-blinkon175",
! # else	/* MSDOS or Win32 console */
  				(char_u *)"n-v-c:block,o:hor50,i-ci:hor15,r-cr:hor30,sm:block",
  # endif
  				    (char_u *)0L}
--- 1305,1311 ----
  			    {
  # ifdef FEAT_GUI
  				(char_u *)"n-v-c:block-Cursor/lCursor,ve:ver35-Cursor,o:hor50-Cursor,i-ci:ver25-Cursor/lCursor,r-cr:hor20-Cursor/lCursor,sm:block-Cursor-blinkwait175-blinkoff150-blinkon175",
! # else	/* Win32 console */
  				(char_u *)"n-v-c:block,o:hor50,i-ci:hor15,r-cr:hor30,sm:block",
  # endif
  				    (char_u *)0L}
***************
*** 1596,1602 ****
      {"isident",	    "isi",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_isi, PV_NONE,
  			    {
! #if defined(MSDOS) || defined(MSWIN)
  			    (char_u *)"@,48-57,_,128-167,224-235",
  #else
  # ifdef EBCDIC
--- 1584,1590 ----
      {"isident",	    "isi",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_isi, PV_NONE,
  			    {
! #if defined(MSWIN)
  			    (char_u *)"@,48-57,_,128-167,224-235",
  #else
  # ifdef EBCDIC
***************
*** 1622,1628 ****
  				    "251-254",
  #else
  				(char_u *)"@,48-57,_",
! # if defined(MSDOS) || defined(MSWIN)
  				(char_u *)"@,48-57,_,128-167,224-235"
  # else
  				ISK_LATIN1
--- 1610,1616 ----
  				    "251-254",
  #else
  				(char_u *)"@,48-57,_",
! # if defined(MSWIN)
  				(char_u *)"@,48-57,_,128-167,224-235"
  # else
  				ISK_LATIN1
***************
*** 1632,1639 ****
      {"isprint",	    "isp",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
  			    (char_u *)&p_isp, PV_NONE,
  			    {
! #if defined(MSDOS) || defined(MSWIN) \
! 		|| (defined(MACOS) && !defined(MACOS_X)) \
  		|| defined(VMS)
  			    (char_u *)"@,~-255",
  #else
--- 1620,1626 ----
      {"isprint",	    "isp",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
  			    (char_u *)&p_isp, PV_NONE,
  			    {
! #if defined(MSWIN) || (defined(MACOS) && !defined(MACOS_X)) \
  		|| defined(VMS)
  			    (char_u *)"@,~-255",
  #else
***************
*** 1672,1690 ****
      {"keywordprg",  "kp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_kp, PV_KP,
  			    {
! #if defined(MSDOS) || defined(MSWIN)
  			    (char_u *)":help",
  #else
! #ifdef VMS
  			    (char_u *)"help",
- #else
- # ifdef USEMAN_S
- 			    (char_u *)"man -s",
  # else
  			    (char_u *)"man",
  # endif
  #endif
- #endif
  				(char_u *)0L} SCRIPTID_INIT},
      {"langmap",     "lmap", P_STRING|P_VI_DEF|P_ONECOMMA|P_NODUP|P_SECURE,
  #ifdef FEAT_LANGMAP
--- 1659,1677 ----
      {"keywordprg",  "kp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_kp, PV_KP,
  			    {
! #if defined(MSWIN)
  			    (char_u *)":help",
  #else
! # ifdef VMS
  			    (char_u *)"help",
  # else
+ #  ifdef USEMAN_S
+ 			    (char_u *)"man -s",
+ #  else
  			    (char_u *)"man",
+ #  endif
  # endif
  #endif
  				(char_u *)0L} SCRIPTID_INIT},
      {"langmap",     "lmap", P_STRING|P_VI_DEF|P_ONECOMMA|P_NODUP|P_SECURE,
  #ifdef FEAT_LANGMAP
***************
*** 1729,1735 ****
      {"lines",	    NULL,   P_NUM|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RCLR,
  			    (char_u *)&Rows, PV_NONE,
  			    {
! #if defined(MSDOS) || defined(WIN3264)
  			    (char_u *)25L,
  #else
  			    (char_u *)24L,
--- 1716,1722 ----
      {"lines",	    NULL,   P_NUM|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RCLR,
  			    (char_u *)&Rows, PV_NONE,
  			    {
! #if defined(WIN3264)
  			    (char_u *)25L,
  #else
  			    (char_u *)24L,
***************
*** 1880,1886 ****
      {"mouse",	    NULL,   P_STRING|P_VI_DEF|P_FLAGLIST,
  			    (char_u *)&p_mouse, PV_NONE,
  			    {
! #if defined(MSDOS) || defined(WIN3264)
  				(char_u *)"a",
  #else
  				(char_u *)"",
--- 1867,1873 ----
      {"mouse",	    NULL,   P_STRING|P_VI_DEF|P_FLAGLIST,
  			    (char_u *)&p_mouse, PV_NONE,
  			    {
! #if defined(WIN3264)
  				(char_u *)"a",
  #else
  				(char_u *)"",
***************
*** 1903,1909 ****
      {"mousemodel",  "mousem", P_STRING|P_VI_DEF,
  			    (char_u *)&p_mousem, PV_NONE,
  			    {
! #if defined(MSDOS) || defined(MSWIN)
  				(char_u *)"popup",
  #else
  # if defined(MACOS)
--- 1890,1896 ----
      {"mousemodel",  "mousem", P_STRING|P_VI_DEF,
  			    (char_u *)&p_mousem, PV_NONE,
  			    {
! #if defined(MSWIN)
  				(char_u *)"popup",
  #else
  # if defined(MACOS)
***************
*** 1962,1968 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"opendevice",  "odev", P_BOOL|P_VI_DEF,
! #if defined(MSDOS) || defined(MSWIN)
  			    (char_u *)&p_odev, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
--- 1949,1955 ----
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"opendevice",  "odev", P_BOOL|P_VI_DEF,
! #if defined(MSWIN)
  			    (char_u *)&p_odev, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
***************
*** 2008,2014 ****
      {"path",	    "pa",   P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_path, PV_PATH,
  			    {
! #if defined AMIGA || defined MSDOS || defined MSWIN
  			    (char_u *)".,,",
  #else
  # if defined(__EMX__)
--- 1995,2001 ----
      {"path",	    "pa",   P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
  			    (char_u *)&p_path, PV_PATH,
  			    {
! #if defined(AMIGA) || defined(MSWIN)
  			    (char_u *)".,,",
  #else
  # if defined(__EMX__)
***************
*** 2294,2314 ****
  #ifdef VMS
  			    (char_u *)"-",
  #else
! # if defined(MSDOS)
! 			    (char_u *)"command",
! # else
! #  if defined(WIN3264)
  			    (char_u *)"",	/* set in set_init_1() */
! #  else
  			    (char_u *)"sh",
- #  endif
  # endif
  #endif /* VMS */
  				(char_u *)0L} SCRIPTID_INIT},
      {"shellcmdflag","shcf", P_STRING|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_shcf, PV_NONE,
  			    {
! #if defined(MSDOS) || defined(MSWIN)
  			    (char_u *)"/c",
  #else
  			    (char_u *)"-c",
--- 2281,2297 ----
  #ifdef VMS
  			    (char_u *)"-",
  #else
! # if defined(WIN3264)
  			    (char_u *)"",	/* set in set_init_1() */
! # else
  			    (char_u *)"sh",
  # endif
  #endif /* VMS */
  				(char_u *)0L} SCRIPTID_INIT},
      {"shellcmdflag","shcf", P_STRING|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_shcf, PV_NONE,
  			    {
! #if defined(MSWIN)
  			    (char_u *)"/c",
  #else
  			    (char_u *)"-c",
***************
*** 2364,2370 ****
      {"shellxescape", "sxe", P_STRING|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_sxe, PV_NONE,
  			    {
! #if defined(MSDOS) || defined(WIN3264)
  			    (char_u *)"\"&|<>()@^",
  #else
  			    (char_u *)"",
--- 2347,2353 ----
      {"shellxescape", "sxe", P_STRING|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_sxe, PV_NONE,
  			    {
! #if defined(WIN3264)
  			    (char_u *)"\"&|<>()@^",
  #else
  			    (char_u *)"",
***************
*** 2381,2391 ****
  			    {(char_u *)"", (char_u *)"filnxtToO"}
  			    SCRIPTID_INIT},
      {"shortname",   "sn",   P_BOOL|P_VI_DEF,
- #ifdef SHORT_FNAME
- 			    (char_u *)NULL, PV_NONE,
- #else
  			    (char_u *)&p_sn, PV_SN,
- #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"showbreak",   "sbr",  P_STRING|P_VI_DEF|P_RALL,
  #ifdef FEAT_LINEBREAK
--- 2364,2370 ----
***************
*** 2795,2801 ****
      {"viminfo",	    "vi",   P_STRING|P_ONECOMMA|P_NODUP|P_SECURE,
  #ifdef FEAT_VIMINFO
  			    (char_u *)&p_viminfo, PV_NONE,
! #if defined(MSDOS) || defined(MSWIN)
  			    {(char_u *)"", (char_u *)"'100,<50,s10,h,rA:,rB:"}
  #else
  # ifdef AMIGA
--- 2774,2780 ----
      {"viminfo",	    "vi",   P_STRING|P_ONECOMMA|P_NODUP|P_SECURE,
  #ifdef FEAT_VIMINFO
  			    (char_u *)&p_viminfo, PV_NONE,
! #if defined(MSWIN)
  			    {(char_u *)"", (char_u *)"'100,<50,s10,h,rA:,rB:"}
  #else
  # ifdef AMIGA
***************
*** 3187,3193 ****
       * Don't use it if it is empty.
       */
      if (((p = mch_getenv((char_u *)"SHELL")) != NULL && *p != NUL)
! #if defined(MSDOS) || defined(MSWIN)
  # ifdef __EMX__
  	    || ((p = mch_getenv((char_u *)"EMXSHELL")) != NULL && *p != NUL)
  # endif
--- 3166,3172 ----
       * Don't use it if it is empty.
       */
      if (((p = mch_getenv((char_u *)"SHELL")) != NULL && *p != NUL)
! #if defined(MSWIN)
  # ifdef __EMX__
  	    || ((p = mch_getenv((char_u *)"EMXSHELL")) != NULL && *p != NUL)
  # endif
***************
*** 3363,3369 ****
  #ifdef FEAT_POSTSCRIPT
      /* 'printexpr' must be allocated to be able to evaluate it. */
      set_string_default("pexpr",
! # if defined(MSWIN) || defined(MSDOS)
  	    (char_u *)"system('copy' . ' ' . v:fname_in . (&printdevice == '' ? ' LPT1:' : (' \"' . &printdevice . '\"'))) . delete(v:fname_in)"
  # else
  #  ifdef VMS
--- 3342,3348 ----
  #ifdef FEAT_POSTSCRIPT
      /* 'printexpr' must be allocated to be able to evaluate it. */
      set_string_default("pexpr",
! # if defined(MSWIN)
  	    (char_u *)"system('copy' . ' ' . v:fname_in . (&printdevice == '' ? ' LPT1:' : (' \"' . &printdevice . '\"'))) . delete(v:fname_in)"
  # else
  #  ifdef VMS
***************
*** 3513,3520 ****
  		options[opt_idx].flags |= P_DEF_ALLOCED;
  	    }
  
! #if defined(MSDOS) || defined(MSWIN) || defined(MACOS) \
! 		|| defined(VMS)
  	    if (STRCMP(p_enc, "latin1") == 0
  # ifdef FEAT_MBYTE
  		    || enc_utf8
--- 3492,3498 ----
  		options[opt_idx].flags |= P_DEF_ALLOCED;
  	    }
  
! #if defined(MSWIN) || defined(MACOS) || defined(VMS)
  	    if (STRCMP(p_enc, "latin1") == 0
  # ifdef FEAT_MBYTE
  		    || enc_utf8
***************
*** 3793,3799 ****
      set_number_default("window", Rows - 1);
  
      /* For DOS console the default is always black. */
! #if !((defined(MSDOS) || defined(WIN3264)) && !defined(FEAT_GUI))
      /*
       * If 'background' wasn't set by the user, try guessing the value,
       * depending on the terminal name.  Only need to check for terminals
--- 3771,3777 ----
      set_number_default("window", Rows - 1);
  
      /* For DOS console the default is always black. */
! #if !((defined(WIN3264)) && !defined(FEAT_GUI))
      /*
       * If 'background' wasn't set by the user, try guessing the value,
       * depending on the terminal name.  Only need to check for terminals
***************
*** 3836,3842 ****
      static char_u *
  term_bg_default(void)
  {
! #if defined(MSDOS) || defined(WIN3264)
      /* DOS console nearly always black */
      return (char_u *)"dark";
  #else
--- 3814,3820 ----
      static char_u *
  term_bg_default(void)
  {
! #if defined(WIN3264)
      /* DOS console nearly always black */
      return (char_u *)"dark";
  #else
***************
*** 3963,3977 ****
      }
  #endif
  
! #if defined(MSDOS) || defined(WIN3264)
      /*
       * Set 'shellcmdflag', 'shellxquote', and 'shellquote' depending on the
       * 'shell' option.
       * This is done after other initializations, where 'shell' might have been
       * set, but only if they have not been set before.  Default for p_shcf is
       * "/c", for p_shq is "".  For "sh" like  shells it is changed here to
!      * "-c" and "\"", but not for DJGPP, because it starts the shell without
!      * command.com.  And for Win32 we need to set p_sxq instead.
       */
      if (strstr((char *)gettail(p_sh), "sh") != NULL)
      {
--- 3941,3954 ----
      }
  #endif
  
! #if defined(WIN3264)
      /*
       * Set 'shellcmdflag', 'shellxquote', and 'shellquote' depending on the
       * 'shell' option.
       * This is done after other initializations, where 'shell' might have been
       * set, but only if they have not been set before.  Default for p_shcf is
       * "/c", for p_shq is "".  For "sh" like  shells it is changed here to
!      * "-c" and "\"".  And for Win32 we need to set p_sxq instead.
       */
      if (strstr((char *)gettail(p_sh), "sh") != NULL)
      {
***************
*** 3984,3991 ****
  	    options[idx3].def_val[VI_DEFAULT] = p_shcf;
  	}
  
! # ifndef DJGPP
! #  ifdef WIN3264
  	/* Somehow Win32 requires the quotes around the redirection too */
  	idx3 = findoption((char_u *)"sxq");
  	if (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))
--- 3961,3967 ----
  	    options[idx3].def_val[VI_DEFAULT] = p_shcf;
  	}
  
! # ifdef WIN3264
  	/* Somehow Win32 requires the quotes around the redirection too */
  	idx3 = findoption((char_u *)"sxq");
  	if (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))
***************
*** 3993,4006 ****
  	    p_sxq = (char_u *)"\"";
  	    options[idx3].def_val[VI_DEFAULT] = p_sxq;
  	}
! #  else
  	idx3 = findoption((char_u *)"shq");
  	if (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))
  	{
  	    p_shq = (char_u *)"\"";
  	    options[idx3].def_val[VI_DEFAULT] = p_shq;
  	}
- #  endif
  # endif
      }
      else if (strstr((char *)gettail(p_sh), "cmd.exe") != NULL)
--- 3969,3981 ----
  	    p_sxq = (char_u *)"\"";
  	    options[idx3].def_val[VI_DEFAULT] = p_sxq;
  	}
! # else
  	idx3 = findoption((char_u *)"shq");
  	if (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))
  	{
  	    p_shq = (char_u *)"\"";
  	    options[idx3].def_val[VI_DEFAULT] = p_shq;
  	}
  # endif
      }
      else if (strstr((char *)gettail(p_sh), "cmd.exe") != NULL)
***************
*** 4424,4431 ****
  	    }
  
  	    /*
! 	     * allow '=' and ':' as MSDOS command.com allows only one
! 	     * '=' character per "set" command line. grrr. (jw)
  	     */
  	    if (nextchar == '?'
  		    || (prefix == 1
--- 4399,4406 ----
  	    }
  
  	    /*
! 	     * allow '=' and ':' for hystorical reasons (MSDOS command.com
! 	     * allows only one '=' character per "set" command line. grrr. (jw)
  	     */
  	    if (nextchar == '?'
  		    || (prefix == 1
***************
*** 6558,6564 ****
  	{
  	    out_str(T_ME);
  	    redraw_later(CLEAR);
! #if defined(MSDOS) || (defined(WIN3264) && !defined(FEAT_GUI_W32))
  	    /* Since t_me has been set, this probably means that the user
  	     * wants to use this as default colors.  Need to reset default
  	     * background/foreground colors. */
--- 6533,6539 ----
  	{
  	    out_str(T_ME);
  	    redraw_later(CLEAR);
! #if defined(WIN3264) && !defined(FEAT_GUI_W32)
  	    /* Since t_me has been set, this probably means that the user
  	     * wants to use this as default colors.  Need to reset default
  	     * background/foreground colors. */
***************
*** 8794,8805 ****
      }
      limit_screen_size();
  
- #ifdef DJGPP
-     /* avoid a crash by checking for a too large value of 'columns' */
-     if (old_Columns != Columns && full_screen && term_console)
- 	mch_check_columns();
- #endif
- 
      /*
       * If the screen (shell) height has been changed, assume it is the
       * physical screenheight.
--- 8769,8774 ----
***************
*** 10389,10397 ****
  #ifdef FEAT_SMARTINDENT
  	case PV_SI:	return (char_u *)&(curbuf->b_p_si);
  #endif
- #ifndef SHORT_FNAME
  	case PV_SN:	return (char_u *)&(curbuf->b_p_sn);
- #endif
  	case PV_STS:	return (char_u *)&(curbuf->b_p_sts);
  #ifdef FEAT_SEARCHPATH
  	case PV_SUA:	return (char_u *)&(curbuf->b_p_sua);
--- 10358,10364 ----
***************
*** 10722,10730 ****
  #endif
  	    buf->b_p_sts = p_sts;
  	    buf->b_p_sts_nopaste = p_sts_nopaste;
- #ifndef SHORT_FNAME
  	    buf->b_p_sn = p_sn;
- #endif
  #ifdef FEAT_COMMENTS
  	    buf->b_p_com = vim_strsave(p_com);
  #endif
--- 10689,10695 ----
*** ../vim-7.4.1398/src/option.h	2016-02-21 23:01:47.445323348 +0100
--- src/option.h	2016-02-23 14:29:16.731691631 +0100
***************
*** 18,24 ****
  #ifdef AMIGA
  # define DFLT_EFM	"%f>%l:%c:%t:%n:%m,%f:%l: %t%*\\D%n: %m,%f %l %t%*\\D%n: %m,%*[^\"]\"%f\"%*\\D%l: %m,%f:%l:%m,%f|%l| %m"
  #else
! # if defined(MSDOS) || defined(WIN3264)
  #  define DFLT_EFM	"%f(%l) : %t%*\\D%n: %m,%*[^\"]\"%f\"%*\\D%l: %m,%f(%l) : %m,%*[^ ] %f %l: %m,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,%f|%l| %m"
  # else
  #  if defined(__EMX__)	/* put most common here (i.e. gcc format) at front */
--- 18,24 ----
  #ifdef AMIGA
  # define DFLT_EFM	"%f>%l:%c:%t:%n:%m,%f:%l: %t%*\\D%n: %m,%f %l %t%*\\D%n: %m,%*[^\"]\"%f\"%*\\D%l: %m,%f:%l:%m,%f|%l| %m"
  #else
! # if defined(WIN3264)
  #  define DFLT_EFM	"%f(%l) : %t%*\\D%n: %m,%*[^\"]\"%f\"%*\\D%l: %m,%f(%l) : %m,%*[^ ] %f %l: %m,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,%f|%l| %m"
  # else
  #  if defined(__EMX__)	/* put most common here (i.e. gcc format) at front */
***************
*** 386,395 ****
  #ifdef FEAT_BROWSE
  EXTERN char_u	*p_bsdir;	/* 'browsedir' */
  #endif
- #ifdef MSDOS
- EXTERN int	p_biosk;	/* 'bioskey' */
- EXTERN int	p_consk;	/* 'conskey' */
- #endif
  #ifdef FEAT_LINEBREAK
  EXTERN char_u	*p_breakat;	/* 'breakat' */
  #endif
--- 386,391 ----
***************
*** 671,677 ****
  #ifdef FEAT_MZSCHEME
  EXTERN long	p_mzq;		/* 'mzquantum */
  #endif
! #if defined(MSDOS) || defined(MSWIN)
  EXTERN int	p_odev;		/* 'opendevice' */
  #endif
  EXTERN char_u	*p_opfunc;	/* 'operatorfunc' */
--- 667,673 ----
  #ifdef FEAT_MZSCHEME
  EXTERN long	p_mzq;		/* 'mzquantum */
  #endif
! #if defined(MSWIN)
  EXTERN int	p_odev;		/* 'opendevice' */
  #endif
  EXTERN char_u	*p_opfunc;	/* 'operatorfunc' */
***************
*** 1074,1082 ****
  #ifdef FEAT_SMARTINDENT
      , BV_SI
  #endif
- #ifndef SHORT_FNAME
      , BV_SN
- #endif
  #ifdef FEAT_SYN_HL
      , BV_SMC
      , BV_SYN
--- 1070,1076 ----
*** ../vim-7.4.1398/src/os_msdos.c	2016-02-20 13:54:39.145147032 +0100
--- src/os_msdos.c	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,3086 ****
- /* vi:set ts=8 sts=4 sw=4:
-  *
-  * VIM - Vi IMproved	by Bram Moolenaar
-  *
-  * Do ":help uganda"  in Vim to read copying and usage conditions.
-  * Do ":help credits" in Vim to see a list of people who contributed.
-  * See README.txt for an overview of the Vim source code.
-  */
- 
- /*
-  * os_msdos.c
-  *
-  * MSDOS system-dependent routines.
-  * A cheap plastic imitation of the amiga dependent code.
-  * A lot in this file was made by Juergen Weigert (jw).
-  *
-  * DJGPP changes by Gert van Antwerpen
-  * Faster text screens by John Lange (jlange@zilker.net)
-  * Windows clipboard functionality added by David Kotchan (dk)
-  *
-  * Some functions are also used for Win16 (MS-Windows 3.1).
-  */
- 
- #include "vim.h"
- 
- /* cproto fails on missing include files */
- #ifndef PROTO
- # include <conio.h>
- #endif
- 
- #ifndef PROTO
- # include <bios.h>
- # ifdef DJGPP
- #  include <dpmi.h>
- #  include <signal.h>
- #  include <sys/movedata.h>
- #  include <crt0.h>
- #  ifdef FEAT_CLIPBOARD
- #   include <sys/segments.h>
- #  endif
- # else
- #  include <alloc.h>
- # endif
- #endif
- 
- #if defined(DJGPP) || defined(PROTO)
- # define _cdecl	    /* DJGPP doesn't have this */
- #endif
- 
- static int cbrk_pressed = FALSE;    /* set by ctrl-break interrupt */
- static int ctrlc_pressed = FALSE;   /* set when ctrl-C or ctrl-break detected */
- static int delayed_redraw = FALSE;  /* set when ctrl-C detected */
- 
- static int bioskey_read = _NKEYBRD_READ;   /* bioskey() argument: read key */
- static int bioskey_ready = _NKEYBRD_READY; /* bioskey() argument: key ready? */
- 
- #ifdef FEAT_MOUSE
- static int mouse_avail = FALSE;		/* mouse present */
- static int mouse_active;		/* mouse enabled */
- static int mouse_hidden;		/* mouse not shown */
- static int mouse_click = -1;		/* mouse status */
- static int mouse_last_click = -1;	/* previous status at click */
- static int mouse_x = -1;		/* mouse x coordinate */
- static int mouse_y = -1;		/* mouse y coordinate */
- static long mouse_click_time = 0;	/* biostime() of last click */
- static int mouse_click_count = 0;	/* count for multi-clicks */
- static int mouse_click_x = 0;		/* x of previous mouse click */
- static int mouse_click_y = 0;		/* y of previous mouse click */
- static linenr_T mouse_topline = 0;	/* w_topline at previous mouse click */
- #ifdef FEAT_DIFF
- static int mouse_topfill = 0;		/* w_topfill at previous mouse click */
- #endif
- static int mouse_x_div = 8;		/* column = x coord / mouse_x_div */
- static int mouse_y_div = 8;		/* line   = y coord / mouse_y_div */
- #endif
- 
- #define BIOSTICK    55			/* biostime() increases one tick about
- 					   every 55 msec */
- 
- static int orig_attr = 0x0700;		/* video attributes when starting */
- 
- static int S_iLeft = 0;			/* Scroll window; these are 1 offset */
- static int S_iTop = 0;
- static int S_iRight = 0;
- static int S_iBottom = 0;
- 
- /*
-  * Need to remember the values, because we set horizontal and vertical
-  * edges separately.
-  */
-     static void
- mywindow(int iLeft, int iTop, int iRight, int iBottom)
- {
-     S_iLeft = iLeft;
-     S_iTop = iTop;
-     S_iRight = iRight;
-     S_iBottom = iBottom;
-     window(iLeft, iTop, iRight, iBottom);
- }
- 
- #ifdef DJGPP
- /*
-  * For DJGPP, use our own functions for fast text screens.  JML 1/18/98
-  */
- 
- unsigned long	S_ulScreenBase = 0xb8000;
- unsigned short	S_uiAttribute = 0;
- int		S_iCurrentRow = 0;	/* These are 0 offset */
- int		S_iCurrentColumn = 0;
- short		S_selVideo;	/* Selector for DJGPP direct video transfers */
- 
- /*
-  * Use burst writes to improve mch_write speed - VJN 01/10/99
-  */
- unsigned short	S_linebuffer[8000]; /* <VN> enough for 160x50 */
- unsigned short	S_blankbuffer[256]; /* <VN> max length of console line */
- unsigned short	*S_linebufferpos = S_linebuffer;
- int		S_iBufferRow;
- int		S_iBufferColumn;
- 
-     static void
- myflush(void)
- {
-     if (S_linebufferpos != S_linebuffer)
-     {
- 	_dosmemputw(S_linebuffer, (S_linebufferpos - S_linebuffer),
- 		S_ulScreenBase
- 		      + S_iBufferRow * (Columns << 1) + (S_iBufferColumn << 1));
- 	S_linebufferpos = S_linebuffer;
-     }
- }
- 
-     static void
- mygotoxy(int x, int y)
- {
-     S_iCurrentRow = y - 1;
-     S_iCurrentColumn = x - 1;
- }
- 
- /*
-  * Set the system cursor to our cursor position.
-  */
-     static void
- set_sys_cursor(void)
- {
-     if (term_console && full_screen)
-     {
- 	myflush();
- 	gotoxy(S_iCurrentColumn + 1, S_iCurrentRow + 1);
-     }
- }
- 
-     static void
- setblankbuffer(unsigned short uiValue)
- {
-     int				i;
-     static unsigned short	olduiValue = 0;
- 
-     if (olduiValue != uiValue)
-     {
- 	/* Load blank line buffer with spaces */
- 	for (i = 0; i < Columns; ++i)
- 	    S_blankbuffer[i] = uiValue;
- 	olduiValue = uiValue;
-     }
- }
- 
-     static void
- myclreol(void)
- {
-     /* Clear to end of line */
-     setblankbuffer(S_uiAttribute | ' ');
-     _dosmemputw(S_blankbuffer, S_iRight - S_iCurrentColumn, S_ulScreenBase
- 			 + (S_iCurrentRow) * (Columns << 1)
- 			 + (S_iCurrentColumn << 1));
- }
- 
-     static void
- myclrscr(void)
- {
-     /* Clear whole screen */
-     short	iColumn;
-     int		endpoint = (Rows * Columns) << 1;
- 
-     setblankbuffer(S_uiAttribute | ' ');
- 
-     for (iColumn = 0; iColumn < endpoint; iColumn += (Columns << 1))
- 	_dosmemputw(S_blankbuffer, Columns, S_ulScreenBase + iColumn);
- }
- 
-     static void
- mydelline(void)
- {
-     short iRow, iColumn;
- 
-     iColumn = (S_iLeft - 1) << 1;
- 
-     /* Copy the lines underneath */
-     for (iRow = S_iCurrentRow; iRow < S_iBottom - 1; iRow++)
- 	movedata(S_selVideo, (((iRow + 1) * Columns) << 1) + iColumn,
- 		S_selVideo, ((iRow * Columns) << 1) + iColumn,
- 		(S_iRight - S_iLeft + 1) << 1);
- 
-     /* Clear the new row */
-     setblankbuffer(S_uiAttribute | ' ');
- 
-     _dosmemputw(S_blankbuffer, (S_iRight - S_iLeft) + 1, S_ulScreenBase
- 			 + (S_iBottom - 1) * (Columns << 1) + iColumn);
- }
- 
-     static void
- myinsline(void)
- {
-     short iRow, iColumn;
- 
-     iColumn = (S_iLeft - 1) << 1;
- 
-     /* Copy the lines underneath */
-     for (iRow = S_iBottom - 1; iRow >= S_iTop; iRow--)
- 	movedata(S_selVideo, (((iRow - 1) * Columns) << 1) + iColumn,
- 		S_selVideo, ((iRow * Columns) << 1) + iColumn,
- 		(S_iRight - S_iLeft + 1) << 1);
- 
-     /* Clear the new row */
-     setblankbuffer(S_uiAttribute | ' ');
- 
-     _dosmemputw(S_blankbuffer, (S_iRight - S_iLeft) + 1, S_ulScreenBase
- 			 + (S_iTop - 1) * (Columns << 1) + iColumn);
- }
- 
- /*
-  * Scroll the screen one line up, clear the last line.
-  */
-     static void
- myscroll(void)
- {
-     short		iRow, iColumn;
- 
-     iColumn = (S_iLeft - 1) << 1;
- 
-     /* Copy the screen */
-     for (iRow = S_iTop; iRow < S_iBottom; iRow++)
- 	movedata(S_selVideo, ((iRow * Columns) << 1) + iColumn,
- 		S_selVideo, (((iRow - 1) * Columns) << 1) + iColumn,
- 		(S_iRight - S_iLeft + 1) << 1);
- 
-     /* Clear the bottom row */
-     setblankbuffer(S_uiAttribute | ' ');
- 
-     _dosmemputw(S_blankbuffer, (S_iRight - S_iLeft) + 1, S_ulScreenBase
- 			 + (S_iBottom - 1) * (Columns << 1) + iColumn);
- }
- 
-     static int
- myputch(int iChar)
- {
-     unsigned short uiValue;
- 
-     if (iChar == '\n')
-     {
- 	myflush();
- 	if (S_iCurrentRow >= S_iBottom - S_iTop)
- 	    myscroll();
- 	else
- 	{
- 	    S_iCurrentColumn = S_iLeft - 1;
- 	    S_iCurrentRow++;
- 	}
-     }
-     else if (iChar == '\r')
-     {
- 	myflush();
- 	S_iCurrentColumn = S_iLeft - 1;
-     }
-     else if (iChar == '\b')
-     {
- 	myflush();
- 	if (S_iCurrentColumn >= S_iLeft)
- 	    S_iCurrentColumn--;
-     }
-     else if (iChar == 7)
-     {
- 	sound(440);	/* short beep */
- 	delay(200);
- 	nosound();
-     }
-     else
-     {
- 	uiValue = S_uiAttribute | (unsigned char)iChar;
- 
- 	/*
- 	 * Normal char - are we starting to buffer?
- 	 */
- 	if (S_linebufferpos == S_linebuffer)
- 	{
- 	    S_iBufferColumn = S_iCurrentColumn;
- 	    S_iBufferRow = S_iCurrentRow;
- 	}
- 
- 	*S_linebufferpos++ = uiValue;
- 
- 	S_iCurrentColumn++;
- 	if (S_iCurrentColumn >= S_iRight && S_iCurrentRow >= S_iBottom - S_iTop)
- 	{
- 	    myflush();
- 	    myscroll();
- 	    S_iCurrentColumn = S_iLeft - 1;
- 	    S_iCurrentRow++;
- 	}
-     }
- 
-     return 0;
- }
- 
-     static void
- mytextinit(struct text_info *pTextinfo)
- {
-     S_selVideo = __dpmi_segment_to_descriptor(S_ulScreenBase >> 4);
-     S_uiAttribute = pTextinfo->normattr << 8;
- }
- 
-     static void
- get_screenbase(void)
- {
-     static union REGS	    regs;
- 
-     /* old Hercules grafic card has different base address (Macewicz) */
-     regs.h.ah = 0x0f;
-     (void)int86(0x10, &regs, &regs);	/* int 10 0f */
-     if (regs.h.al == 0x07)		/* video mode 7 -- hercules mono */
- 	S_ulScreenBase = 0xb0000;
-     else
- 	S_ulScreenBase = 0xb8000;
- }
- 
-     static void
- mytextattr(int iAttribute)
- {
-     S_uiAttribute = (unsigned short)iAttribute << 8;
- }
- 
-     static void
- mynormvideo(void)
- {
-     mytextattr(orig_attr);
- }
- 
-     static void
- mytextcolor(int iTextColor)
- {
-     S_uiAttribute = (unsigned short)((S_uiAttribute & 0xf000)
- 					   | (unsigned short)iTextColor << 8);
- }
- 
-     static void
- mytextbackground(int iBkgColor)
- {
-     S_uiAttribute = (unsigned short)((S_uiAttribute & 0x0f00)
- 					 | (unsigned short)(iBkgColor << 12));
- }
- /*
-  * Getdigits: Get a number from a string and skip over it.
-  * Note: the argument is a pointer to a char_u pointer!
-  */
- 
-     static long
- mygetdigits(char_u **pp)
- {
-     char_u	*p;
-     long	retval = 0;
- 
-     p = *pp;
-     if (*p == '-')		/* skip negative sign */
- 	++p;
-     while (VIM_ISDIGIT(*p))
-     {
- 	retval = (retval * 10) + (*p - '0');
- 	++p;
-     }
-     if (**pp == '-')		/* process negative sign */
- 	retval = -retval;
- 
-     *pp = p;
-     return retval;
- }
- #else
- # define mygotoxy gotoxy
- # define myputch putch
- # define myscroll scroll
- # define mynormvideo normvideo
- # define mytextattr textattr
- # define mytextcolor textcolor
- # define mytextbackground textbackground
- # define mygetdigits getdigits
- # define myclreol clreol
- # define myclrscr clrscr
- # define myinsline insline
- # define mydelline delline
- #endif
- 
- static const struct
- {
-     char_u	scancode;
-     char_u	metakey;
- } altkey_table[] =
- {
-     {0x1e, 0xe1}, /* a */
-     {0x30, 0xe2}, /* b */
-     {0x2e, 0xe3}, /* c */
-     {0x20, 0xe4}, /* d */
-     {0x12, 0xe5}, /* e */
-     {0x21, 0xe6}, /* f */
-     {0x22, 0xe7}, /* g */
-     {0x23, 0xe8}, /* h */
-     {0x17, 0xe9}, /* i */
-     {0x24, 0xea}, /* j */
-     {0x25, 0xeb}, /* k */
-     {0x26, 0xec}, /* l */
-     {0x32, 0xed}, /* m */
-     {0x31, 0xee}, /* n */
-     {0x18, 0xef}, /* o */
-     {0x19, 0xf0}, /* p */
-     {0x10, 0xf1}, /* q */
-     {0x13, 0xf2}, /* r */
-     {0x1f, 0xf3}, /* s */
-     {0x14, 0xf4}, /* t */
-     {0x16, 0xf5}, /* u */
-     {0x2f, 0xf6}, /* v */
-     {0x11, 0xf7}, /* w */
-     {0x2d, 0xf8}, /* x */
-     {0x15, 0xf9}, /* y */
-     {0x2c, 0xfa}, /* z */
-     {0x78, 0xb1}, /* 1 */
-     {0x79, 0xb2}, /* 2 */
-     {0x7a, 0xb3}, /* 3 */
-     {0x7b, 0xb4}, /* 4 */
-     {0x7c, 0xb5}, /* 5 */
-     {0x7d, 0xb6}, /* 6 */
-     {0x7e, 0xb7}, /* 7 */
-     {0x7f, 0xb8}, /* 8 */
-     {0x80, 0xb9}, /* 9 */
-     {0x81, 0xb0}, /* 0 */
- };
- 
- /*
-  * Translate extended keycodes into meta-chars where applicable
-  */
-     static int
- translate_altkeys(int rawkey)
- {
-     int i, c;
- 
-     if ((rawkey & 0xff) == 0)
-     {
- 	c = (rawkey >> 8);
- 	for (i = sizeof(altkey_table) / sizeof(altkey_table[0]); --i >= 0; )
- 	{
- 	    if (c == altkey_table[i].scancode)
- 		return (int)altkey_table[i].metakey;
- 	}
-     }
-     return rawkey;
- }
- 
- /*
-  * Set normal fg/bg color, based on T_ME.  Called when t_me has been set.
-  */
-     void
- mch_set_normal_colors(void)
- {
-     char_u	*p;
-     int		n;
- 
-     cterm_normal_fg_color = (orig_attr & 0xf) + 1;
-     cterm_normal_bg_color = ((orig_attr >> 4) & 0xf) + 1;
-     if (T_ME[0] == ESC && T_ME[1] == '|')
-     {
- 	p = T_ME + 2;
- 	n = getdigits(&p);
- 	if (*p == 'm' && n > 0)
- 	{
- 	    cterm_normal_fg_color = (n & 0xf) + 1;
- 	    cterm_normal_bg_color = ((n >> 4) & 0xf) + 1;
- 	}
-     }
- }
- 
- #if defined(MCH_CURSOR_SHAPE) || defined(PROTO)
- /*
-  * Save/restore the shape of the cursor.
-  * call with FALSE to save, TRUE to restore
-  */
-     static void
- mch_restore_cursor_shape(int restore)
- {
-     static union REGS	    regs;
-     static int		    saved = FALSE;
- 
-     if (restore)
-     {
- 	if (saved)
- 	    regs.h.ah = 0x01;	    /* Set Cursor */
- 	else
- 	    return;
-     }
-     else
-     {
- 	regs.h.ah = 0x03;	    /* Get Cursor */
- 	regs.h.bh = 0x00;	    /* Page */
- 	saved = TRUE;
-     }
- 
-     (void)int86(0x10, &regs, &regs);
- }
- 
- /*
-  * Set the shape of the cursor.
-  * 'thickness' can be from 0 (thin) to 7 (block)
-  */
-     static void
- mch_set_cursor_shape(int thickness)
- {
-     union REGS	    regs;
- 
-     regs.h.ch = 7 - thickness;	    /* Starting Line */
-     regs.h.cl = 7;		    /* Ending Line */
-     regs.h.ah = 0x01;		    /* Set Cursor */
-     (void)int86(0x10, &regs, &regs);
- }
- 
-     void
- mch_update_cursor(void)
- {
-     int		idx;
-     int		thickness;
- 
-     /*
-      * How the cursor is drawn depends on the current mode.
-      */
-     idx = get_shape_idx(FALSE);
- 
-     if (shape_table[idx].shape == SHAPE_BLOCK)
- 	thickness = 7;
-     else
- 	thickness = (7 * shape_table[idx].percentage + 90) / 100;
-     mch_set_cursor_shape(thickness);
- }
- #endif
- 
- /*
-  * Return amount of memory currently available in Kbyte.
-  */
-     long_u
- mch_avail_mem(int special)
- {
- #ifdef DJGPP
-     return _go32_dpmi_remaining_virtual_memory() >> 10;
- #else
-     return coreleft() >> 10;
- #endif
- }
- 
- #ifdef FEAT_MOUSE
- 
- /*
-  * Set area where mouse can be moved to: The whole screen.
-  * Rows and Columns must be valid when calling!
-  */
-     static void
- mouse_area(void)
- {
-     union REGS	    regs;
- 
-     if (mouse_avail)
-     {
- 	regs.x.cx = 0;	/* mouse visible between cx and dx */
- 	regs.x.dx = Columns * mouse_x_div - 1;
- 	regs.x.ax = 7;
- 	(void)int86(0x33, &regs, &regs);
- 
- 	regs.x.cx = 0;	/* mouse visible between cx and dx */
- 	regs.x.dx = Rows * mouse_y_div - 1;
- 	regs.x.ax = 8;
- 	(void)int86(0x33, &regs, &regs);
-     }
- }
- 
-     static void
- show_mouse(int on)
- {
-     static int	    was_on = FALSE;
-     union REGS	    regs;
- 
-     if (mouse_avail)
-     {
- 	if (!mouse_active || mouse_hidden)
- 	    on = FALSE;
- 	/*
- 	 * Careful: Each switch on must be compensated by exactly one switch
- 	 * off
- 	 */
- 	if ((on && !was_on) || (!on && was_on))
- 	{
- 	    was_on = on;
- 	    regs.x.ax = on ? 1 : 2;
- 	    int86(0x33, &regs, &regs);	/* show mouse */
- 	    if (on)
- 		mouse_area();
- 	}
-     }
- }
- 
- #endif
- 
- /*
-  * Version of kbhit() and getch() that use direct console I/O.
-  * This avoids trouble with CTRL-P and the like, and should work over a telnet
-  * connection (it works for Xvi).
-  */
- 
- static int cons_key = -1;
- 
- /*
-  * Try to get one character directly from the console.
-  * If there is a key, it is stored in cons_key.
-  * Only call when cons_key is -1!
-  */
-     static void
- cons_getkey(void)
- {
-     union REGS regs;
- 
-     /* call DOS function 6: Direct console I/O */
-     regs.h.ah = 0x06;
-     regs.h.dl = 0xff;
-     (void)intdos(&regs, &regs);
-     if ((regs.x.flags & 0x40) == 0)	/* zero flag not set? */
- 	cons_key = (regs.h.al & 0xff);
- }
- 
- /*
-  * Return TRUE if a character is available.
-  */
-     static int
- cons_kbhit(void)
- {
-     if (cons_key < 0)
- 	cons_getkey();
-     return (cons_key >= 0);
- }
- 
- /*
-  * Return a character from the console.
-  * Should only be called when vim_kbhit() returns TRUE.
-  */
-     static int
- cons_getch(void)
- {
-     int	    c = -1;
- 
-     if (cons_key < 0)
- 	cons_getkey();
-     c = cons_key;
-     cons_key = -1;
-     return c;
- }
- 
- 
- #ifdef DJGPP
- /*
-  * DJGPP provides a kbhit() function that goes to the BIOS instead of DOS.
-  * This doesn't work for terminals connected to a serial port.
-  * Redefine kbhit() here to make it work.
-  */
-     static int
- vim_kbhit(void)
- {
-     union REGS regs;
- 
-     regs.h.ah = 0x0b;
-     (void)intdos(&regs, &regs);
-     return regs.h.al;
- }
- 
- #ifdef kbhit
- # undef kbhit	    /* might have been defined in conio.h */
- #endif
- #define kbhit()	vim_kbhit()
- 
- #endif
- 
- /*
-  * Simulate WaitForChar() by slowly polling with bioskey(1) or kbhit().
-  *
-  * If Vim should work over the serial line after a 'ctty com1' we must use
-  * kbhit() and getch(). (jw)
-  * Usually kbhit() is not used, because then CTRL-C and CTRL-P
-  * will be caught by DOS (mool).
-  *
-  * return TRUE if a character is available, FALSE otherwise
-  */
- 
- #define FOREVER 1999999999L
- 
-     static  int
- WaitForChar(long msec)
- {
-     long	starttime = 0;
- 
-     if (msec != 0)
- 	starttime = biostime(0, 0L);
- 
-     for (;;)
-     {
- #ifdef FEAT_MOUSE
- 	long		clicktime;
- 	static int	old_status = 0;
- 	union REGS	regs;
- 	int		x, y;
- 
- 	if (mouse_avail && mouse_active && mouse_click < 0)
- 	{
- 	    regs.x.ax = 3;
- 	    int86(0x33, &regs, &regs);	    /* check mouse status */
- 		/* only recognize button-down and button-up event */
- 	    x = regs.x.cx / mouse_x_div;
- 	    y = regs.x.dx / mouse_y_div;
- 	    if ((old_status == 0) != (regs.x.bx == 0))
- 	    {
- 		if (old_status)	/* button up */
- 		    mouse_click = MOUSE_RELEASE;
- 		else			/* button down */
- 		{
- 		    /*
- 		     * Translate MSDOS mouse events to Vim mouse events.
- 		     * TODO: should handle middle mouse button, by pressing
- 		     * left and right at the same time.
- 		     */
- 		    if (regs.x.bx & MSDOS_MOUSE_LEFT)
- 			mouse_click = MOUSE_LEFT;
- 		    else if (regs.x.bx & MSDOS_MOUSE_RIGHT)
- 			mouse_click = MOUSE_RIGHT;
- 		    else if (regs.x.bx & MSDOS_MOUSE_MIDDLE)
- 			mouse_click = MOUSE_MIDDLE;
- 
- 		    /*
- 		     * Find out if this is a multi-click
- 		     */
- 		    clicktime = biostime(0, 0L);
- 		    if (mouse_click_x == x && mouse_click_y == y
- 			    && mouse_topline == curwin->w_topline
- #ifdef FEAT_DIFF
- 			    && mouse_topfill == curwin->w_topfill
- #endif
- 			    && mouse_click_count != 4
- 			    && mouse_click == mouse_last_click
- 			    && clicktime < mouse_click_time
- 							+ p_mouset / BIOSTICK)
- 			++mouse_click_count;
- 		    else
- 			mouse_click_count = 1;
- 		    mouse_click_time = clicktime;
- 		    mouse_last_click = mouse_click;
- 		    mouse_click_x = x;
- 		    mouse_click_y = y;
- 		    mouse_topline = curwin->w_topline;
- #ifdef FEAT_DIFF
- 		    mouse_topfill = curwin->w_topfill;
- #endif
- 		    SET_NUM_MOUSE_CLICKS(mouse_click, mouse_click_count);
- 		}
- 	    }
- 	    else if (old_status && (x != mouse_x || y != mouse_y))
- 		mouse_click = MOUSE_DRAG;
- 	    old_status = regs.x.bx;
- 	    if (mouse_hidden && mouse_x >= 0 && (mouse_x != x || mouse_y != y))
- 	    {
- 		mouse_hidden = FALSE;
- 		show_mouse(TRUE);
- 	    }
- 	    mouse_x = x;
- 	    mouse_y = y;
- 	}
- #endif
- 
- 	if ((p_consk ? cons_kbhit()
- 				 : p_biosk ? bioskey(bioskey_ready) : kbhit())
- 		|| cbrk_pressed
- #ifdef FEAT_MOUSE
- 						    || mouse_click >= 0
- #endif
- 		)
- 	    return TRUE;
- 	/*
- 	 * Use biostime() to wait until our time is done.
- 	 * We busy-wait here.  Unfortunately, delay() and usleep() have been
- 	 * reported to give problems with the original Windows 95.  This is
- 	 * fixed in service pack 1, but not everybody installed that.
- 	 * The DJGPP implementation of usleep() uses a busy-wait loop too.
- 	 */
- 	if (msec == 0 || (msec != FOREVER
- 			    && biostime(0, 0L) > starttime + msec / BIOSTICK))
- 	    break;
- 
- #ifdef DJGPP
- 	/* Yield the CPU to the next process. */
- 	__dpmi_yield();
- #endif
-     }
-     return FALSE;
- }
- 
- /*
-  * don't do anything for about "msec" msec
-  */
-     void
- mch_delay(
-     long	msec,
-     int		ignoreinput)
- {
-     long	starttime;
- 
-     if (ignoreinput)
-     {
- 	/*
- 	 * We busy-wait here.  Unfortunately, delay() and usleep() have been
- 	 * reported to give problems with the original Windows 95.  This is
- 	 * fixed in service pack 1, but not everybody installed that.
- 	 */
- 	starttime = biostime(0, 0L);
- 	while (biostime(0, 0L) < starttime + msec / BIOSTICK)
- 	    ;
-     }
-     else
- 	WaitForChar(msec);
- }
- 
- /*
-  * mch_write(): write the output buffer to the screen
-  */
-     void
- mch_write(
-     char_u	*s,
-     int		len)
- {
-     char_u	*p;
-     int		row, col;
- 
-     if (term_console && full_screen)
- 	while (len--)
- 	{
- 	    /* translate ESC | sequences into bios calls */
- 	    if (p_wd)	    /* testing: wait a bit for each char */
- 		WaitForChar(p_wd);
- 
- 	    if (s[0] == '\n')
- #ifdef DJGPP
- 	    {
- 		myflush();
- 		S_iCurrentColumn = S_iLeft - 1;
- 	    }
- #else
- 		myputch('\r');
- #endif
- 	    else if (s[0] == ESC && len > 1 && s[1] == '|')
- 	    {
- 		switch (s[2])
- 		{
- #ifdef DJGPP
- 		case 'B':   ScreenVisualBell();
- 			    goto got3;
- #endif
- 		case 'J':
- #ifdef DJGPP
- 			    myflush();
- #endif
- 			    myclrscr();
- 			    goto got3;
- 
- 		case 'K':
- #ifdef DJGPP
- 			    myflush();
- #endif
- 			    myclreol();
- 			    goto got3;
- 
- 		case 'L':
- #ifdef DJGPP
- 			    myflush();
- #endif
- 			    myinsline();
- 			    goto got3;
- 
- 		case 'M':
- #ifdef DJGPP
- 			    myflush();
- #endif
- 			    mydelline();
- got3:			    s += 3;
- 			    len -= 2;
- 			    continue;
- 
- 		case '0':
- 		case '1':
- 		case '2':
- 		case '3':
- 		case '4':
- 		case '5':
- 		case '6':
- 		case '7':
- 		case '8':
- 		case '9':   p = s + 2;
- 			    row = mygetdigits(&p);    /* no check for length! */
- 			    if (p > s + len)
- 				break;
- 			    if (*p == ';')
- 			    {
- 				++p;
- 				col = mygetdigits(&p); /* no check for length! */
- 				if (p > s + len)
- 				    break;
- 				if (*p == 'H' || *p == 'r' || *p == 'V')
- 				{
- #ifdef DJGPP
- 				    myflush();
- #endif
- 				    if (*p == 'H')  /* set cursor position */
- 					mygotoxy(col, row);
- 				    else if (*p == 'V')
- 					mywindow(row, S_iTop, col, S_iBottom);
- 				    else	    /* set scroll region  */
- 					mywindow(S_iLeft, row, S_iRight, col);
- 				    len -= p - s;
- 				    s = p + 1;
- 				    continue;
- 				}
- 			    }
- 			    else if (*p == 'm' || *p == 'f' || *p == 'b')
- 			    {
- 				if (*p == 'm')	    /* set color */
- 				{
- 				    if (row == 0)
- 					mynormvideo();/* reset color */
- 				    else
- 					mytextattr(row);
- 				}
- 				else if (*p == 'f') /* set foreground color */
- 				    mytextcolor(row);
- 				else		    /* set background color */
- 				    mytextbackground(row);
- 
- 				len -= p - s;
- 				s = p + 1;
- 				continue;
- 			    }
- 		}
- 	    }
- 	    myputch(*s++);
- 	}
-     else
-     {
- 	write(1, s, (unsigned)len);
-     }
- }
- 
- /*
-  * mch_inchar(): low level input function.
-  * Get a characters from the keyboard.
-  * If time == 0 do not wait for characters.
-  * If time == n wait a short time for characters.
-  * If time == -1 wait forever for characters.
-  *
-  * return the number of characters obtained
-  */
-     int
- mch_inchar(
-     char_u	*buf,
-     int		maxlen,
-     long	time,
-     int		tb_change_cnt)
- {
-     int		len = 0;
-     int		c;
-     int		tmp_c;
-     static int	nextchar = 0;	    /* may keep character when maxlen == 1 */
- 
-     /*
-      * if we got a ctrl-C when we were busy, there will be a "^C" somewhere
-      * on the screen, so we need to redisplay it.
-      */
-     if (delayed_redraw)
-     {
- 	delayed_redraw = FALSE;
- 	update_screen(CLEAR);
- 	setcursor();
- 	out_flush();
-     }
- 
-     /* return remaining character from last call */
-     if (nextchar)
-     {
- 	*buf = nextchar;
- 	nextchar = 0;
- 	return 1;
-     }
- 
- #ifdef FEAT_MOUSE
-     if (time != 0)
- 	show_mouse(TRUE);
- #endif
- #ifdef DJGPP
-     set_sys_cursor();
- #endif
-     if (time >= 0)
-     {
- 	if (WaitForChar(time) == 0)	/* no character available */
- 	{
- #ifdef FEAT_MOUSE
- 	    show_mouse(FALSE);
- #endif
- 	    return 0;
- 	}
-     }
-     else    /* time == -1 */
-     {
- 	/*
- 	 * If there is no character available within 2 seconds (default)
- 	 * write the autoscript file to disk.  Or cause the CursorHold event
- 	 * to be triggered.
- 	 */
- 	if (WaitForChar(p_ut) == 0)
- 	{
- #ifdef FEAT_AUTOCMD
- 	    if (trigger_cursorhold() && maxlen >= 3)
- 	    {
- 		buf[0] = K_SPECIAL;
- 		buf[1] = KS_EXTRA;
- 		buf[2] = (int)KE_CURSORHOLD;
- 		return 3;
- 	    }
- #endif
- 	    before_blocking();
- 	}
-     }
-     WaitForChar(FOREVER);	/* wait for key or mouse click */
- 
- /*
-  * Try to read as many characters as there are, until the buffer is full.
-  */
-     /*
-      * we will get at least one key. Get more if they are available
-      * After a ctrl-break we have to read a 0 (!) from the buffer.
-      * bioskey(1) will return 0 if no key is available and when a
-      * ctrl-break was typed. When ctrl-break is hit, this does not always
-      * implies a key hit.
-      */
-     cbrk_pressed = FALSE;
- #ifdef FEAT_MOUSE
-     if (mouse_click >= 0 && maxlen >= 5)
-     {
- 	len = 5;
- 	*buf++ = ESC + 128;
- 	*buf++ = 'M';
- 	*buf++ = mouse_click;
- 	*buf++ = mouse_x + '!';
- 	*buf++ = mouse_y + '!';
- 	mouse_click = -1;
-     }
-     else
- #endif
-     {
- #ifdef FEAT_MOUSE
- 	mouse_hidden = TRUE;
- #endif
- 	if (p_biosk && !p_consk)
- 	{
- 	    while ((len == 0 || bioskey(bioskey_ready)) && len < maxlen)
- 	    {
- 		c = translate_altkeys(bioskey(bioskey_read)); /* get the key */
- 		/*
- 		 * translate a few things for inchar():
- 		 * 0x0000 == CTRL-break		-> 3	(CTRL-C)
- 		 * 0x0300 == CTRL-@		-> NUL
- 		 * 0xnn00 == extended key code	-> K_NUL, nn
- 		 * 0xnne0 == enhanced keyboard	-> K_NUL, nn
- 		 * K_NUL			-> K_NUL, 3
- 		 */
- 		if (c == 0)
- 		    c = 3;
- 		else if (c == 0x0300)
- 		    c = NUL;
- 		else if ((c & 0xff) == 0
- 			|| c == K_NUL
- 			|| c == 0x4e2b
- 			|| c == 0x4a2d
- 			|| c == 0x372a
- 			|| ((c & 0xff) == 0xe0 && c != 0xe0))
- 		{
- 		    if (c == K_NUL)
- 			c = 3;
- 		    else
- 			c >>= 8;
- 		    *buf++ = K_NUL;
- 		    ++len;
- 		}
- 
- 		if (len < maxlen)
- 		{
- 		    *buf++ = c;
- 		    len++;
- #ifdef FEAT_MBYTE
- 		    /* Convert from 'termencoding' to 'encoding'. Only
- 		     * translate normal characters, not key codes. */
- 		    if (input_conv.vc_type != CONV_NONE
- 					    && (len == 1 || buf[-2] != K_NUL))
- 			len += convert_input(buf - 1, 1, maxlen - len + 1) - 1;
- #endif
- 		}
- 		else
- 		    nextchar = c;
- 	    }
- 	}
- 	else
- 	{
- 	    while ((len == 0 || (p_consk ? cons_kbhit() : kbhit()))
- 		    && len < maxlen)
- 	    {
- 		switch (c = (p_consk ? cons_getch() : getch()))
- 		{
- 		    case 0:
- 			/* NUL means that there is another character.
- 			 * Get it immediately, because kbhit() doesn't always
- 			 * return TRUE for the second character.
- 			 */
- 			if (p_consk)
- 			    c = cons_getch();
- 			else
- 			    c = getch();
- 			tmp_c = translate_altkeys(c << 8);
- 			if (tmp_c == (c << 8))
- 			{
- 			    *buf++ = K_NUL;
- 			    ++len;
- 			}
- 			else
- 			    c = tmp_c;
- 			break;
- 		    case K_NUL:
- 			*buf++ = K_NUL;
- 			++len;
- 			c = 3;
- 			break;
- 		    case 3:
- 			cbrk_pressed = TRUE;
- 			/*FALLTHROUGH*/
- 		    default:
- 			break;
- 		}
- 		if (len < maxlen)
- 		{
- 		    *buf++ = c;
- 		    ++len;
- 		}
- 		else
- 		    nextchar = c;
- 	    }
- 	}
-     }
- #ifdef FEAT_MOUSE
-     show_mouse(FALSE);
- #endif
- 
-     beep_count = 0;	    /* may beep again now that we got some chars */
-     return len;
- }
- 
- /*
-  * return non-zero if a character is available
-  */
-     int
- mch_char_avail(void)
- {
-     return WaitForChar(0L);
- }
- 
- #ifdef DJGPP
- # define INT_ARG    int
- #else
- # define INT_ARG
- #endif
- 
- /*
-  * function for ctrl-break interrupt
-  */
-     static void interrupt
- #ifdef DJGPP
- catch_cbrk(int a)
- #else
- catch_cbrk(void)
- #endif
- {
-     cbrk_pressed = TRUE;
-     ctrlc_pressed = TRUE;
- }
- 
- #ifndef DJGPP
- /*
-  * ctrl-break handler for DOS. Never called when a ctrl-break is typed, because
-  * we catch interrupt 1b. If you type ctrl-C while Vim is waiting for a
-  * character this function is not called. When a ctrl-C is typed while Vim is
-  * busy this function may be called. By that time a ^C has been displayed on
-  * the screen, so we have to redisplay the screen. We can't do that here,
-  * because we may be called by DOS. The redraw is in mch_inchar().
-  */
-     static int _cdecl
- cbrk_handler(void)
- {
-     delayed_redraw = TRUE;
-     return 1;		    /* resume operation after ctrl-break */
- }
- 
- /*
-  * function for critical error interrupt
-  * For DOS 1 and 2 return 0 (Ignore).
-  * For DOS 3 and later return 3 (Fail)
-  */
-     static void interrupt
- catch_cint(
-     unsigned bp,
-     unsigned di,
-     unsigned si,
-     unsigned ds,
-     unsigned es,
-     unsigned dx,
-     unsigned cx,
-     unsigned bx,
-     unsigned ax)
- {
-     ax = (ax & 0xff00);	    /* set AL to 0 */
-     if (_osmajor >= 3)
- 	ax |= 3;	    /* set AL to 3 */
- }
- #endif
- 
- /*
-  * Set the interrupt vectors for use with Vim on or off.
-  * on == TRUE means as used within Vim
-  */
-     static void
- set_interrupts(int on)
- {
-     static int saved_cbrk;
- #ifndef DJGPP
-     static void interrupt (*old_cint)();
- #endif
-     static void interrupt (*old_cbrk)(INT_ARG);
- 
-     if (on)
-     {
- 	saved_cbrk = getcbrk();		/* save old ctrl-break setting */
- 	setcbrk(0);			/* do not check for ctrl-break */
- #ifdef DJGPP
- 	old_cbrk = signal(SIGINT, catch_cbrk);	/* critical error interrupt */
- #else
- 	old_cint = getvect(0x24);	/* save old critical error interrupt */
- 	setvect(0x24, catch_cint);	/* install our critical error interrupt */
- 	old_cbrk = getvect(0x1B);	/* save old ctrl-break interrupt */
- 	setvect(0x1B, catch_cbrk);	/* install our ctrl-break interrupt */
- 	ctrlbrk(cbrk_handler);		/* vim's ctrl-break handler */
- #endif
- 	if (term_console)
- 	    out_str(T_ME);		/* set colors */
-     }
-     else
-     {
- 	setcbrk(saved_cbrk);		/* restore ctrl-break setting */
- #ifdef DJGPP
- 	signal(SIGINT,old_cbrk);	/* critical error interrupt */
- #else
- 	setvect(0x24, old_cint);	/* restore critical error interrupt */
- 	setvect(0x1B, old_cbrk);	/* restore ctrl-break interrupt */
- #endif
- 	/* restore ctrl-break handler, how ??? */
- 	if (term_console)
- 	    mynormvideo();		/* restore screen colors */
-     }
- }
- 
- /*
-  * We have no job control, fake it by starting a new shell.
-  */
-     void
- mch_suspend(void)
- {
-     suspend_shell();
- }
- 
- extern int _fmode;
- 
- /*
-  * Prepare window for use by Vim.
-  */
-     void
- mch_init(void)
- {
-     union REGS regs;
- 
- #if defined(DJGPP) && defined(FEAT_CLIPBOARD)
-     __dpmi_regs  dpmi_regs;
- #endif
- 
-     /*
-      * Get the video attributes at the cursor.  These will be used as the
-      * default attributes.
-      */
-     regs.h.ah = 0x08;
-     regs.h.bh = 0x00;		/* video page 0 */
-     int86(0x10, &regs, &regs);
-     orig_attr = regs.h.ah;
-     mynormvideo();
-     if (cterm_normal_fg_color == 0)
- 	cterm_normal_fg_color = (orig_attr & 0xf) + 1;
-     if (cterm_normal_bg_color == 0)
- 	cterm_normal_bg_color = ((orig_attr >> 4) & 0xf) + 1;
- 
-     term_console = TRUE;    /* assume using the console for the things here */
-     _fmode = O_BINARY;	    /* we do our own CR-LF translation */
-     out_flush();
-     set_interrupts(TRUE);   /* catch interrupts */
- 
- #ifdef DJGPP
-     /*
-      * Use Long File Names by default, if $LFN not set.
-      */
-     if (getenv("LFN") == NULL)
- 	putenv("LFN=y");
- 
-     get_screenbase();
- #endif
- 
- #ifdef FEAT_MOUSE
- /* find out if a MS compatible mouse is available */
-     regs.x.ax = 0;
-     (void)int86(0x33, &regs, &regs);
-     mouse_avail = regs.x.ax;
-     /* best guess for mouse coordinate computations */
-     mch_get_shellsize();
-     if (Columns <= 40)
- 	mouse_x_div = 16;
-     if (Rows == 30)
- 	mouse_y_div = 16;
- #endif
- 
-     /*
-      * Try switching to 16 colors for background, instead of 8 colors and
-      * blinking.  Does this always work?  Can the old value be restored?
-      */
-     regs.x.ax = 0x1003;
-     regs.h.bl = 0x00;
-     regs.h.bh = 0x00;
-     int86(0x10, &regs, &regs);
- 
-     /*
-      * Test if we have an enhanced AT keyboard.  Write 0xFFFF to the keyboard
-      * buffer and try to read it back.  If we can't in 16 tries, it's an old
-      * type XT keyboard.
-      */
-     regs.h.ah = 0x05;
-     regs.x.cx = 0xffff;
-     int86(0x16, &regs, &regs);
-     if (regs.h.al != 1)	/* skip this when keyboard buffer is full */
-     {
- 	int i;
- 
- 	for (i = 0; i < 16; ++i)
- 	{
- 	    regs.h.ah = 0x10;
- 	    int86(0x16, &regs, &regs);
- 	    if (regs.x.ax == 0xffff)
- 		break;
- 	}
- 	if (i == 16)	/* 0xffff not read, must be old keyboard */
- 	{
- 	    bioskey_read = 0;
- 	    bioskey_ready = 1;
- 	}
-     }
- 
- #ifdef MCH_CURSOR_SHAPE
-     /* Save the old cursor shape */
-     mch_restore_cursor_shape(FALSE);
-     /* Initialise the cursor shape */
-     mch_update_cursor();
- #endif
- 
- #if defined(DJGPP) && defined(FEAT_CLIPBOARD)
-     /*
-      * Check to see if the Windows clipboard is available, ie. are we
-      * running from a DOS session within Windows.  Obviously, the Windows
-      * clipboard will not be available if we're running under pure DOS.
-      *
-      * int 0x2f, AX = 0x1700 identifies the Windows version we're running
-      * under.  Upon return from the interrupt, if AX is unchanged, we're
-      * running under pure DOS and no Windows clipboard is available.
-      *
-      * Remark: could use int86() here but __dpmi_int() is recommended in
-      * the DJGPP docs, since int86() doesn't cover all available interrupts.
-      */
-     dpmi_regs.x.ax = 0x1700;
-     if (__dpmi_int(0x2f, &dpmi_regs) == -1)
- 	/* real-mode interrupt failed? */
- 	dpmi_regs.x.ax = 0x1700;	/* force failure */
- 
-     if (dpmi_regs.x.ax == 0x1700)	/* no change in AX? */
- 	clip_init(FALSE);		/* no clipboard available, too bad */
-     else				/* else, running under Windows, OK */
- 	clip_init(TRUE);		/* clipboard is available */
- #endif
- }
- 
-     int
- mch_check_win(
-     int		argc,
-     char	**argv)
- {
-     /* store argv[0], may be used for $VIM */
-     if (*argv[0] != NUL)
- 	exe_name = FullName_save((char_u *)argv[0], FALSE);
- 
-     /*
-      * Try the DOS search path.  The executable may in
-      * fact be called differently, so try this last.
-      */
-     if (exe_name == NULL || *exe_name == NUL)
- 	exe_name = searchpath("vim.exe");
- 
-     if (isatty(1))
- 	return OK;
-     return FAIL;
- }
- 
- /*
-  * Return TRUE if the input comes from a terminal, FALSE otherwise.
-  */
-     int
- mch_input_isatty(void)
- {
-     if (isatty(read_cmd_fd))
- 	return TRUE;
-     return FALSE;
- }
- 
- #if defined(USE_FNAME_CASE) || defined(PROTO)
- /*
-  * fname_case(): Set the case of the file name, if it already exists.
-  * TODO: should expand short to long file names.  Need to use DOS interrupts,
-  * see DJGPP sources libc/dos/dir/findfirs.c.
-  */
-     void
- fname_case(char_u *name, int len)
- {
-     char_u	    *tail;
-     struct ffblk    fb;
- 
-     slash_adjust(name);
-     if (findfirst(name, &fb, 0) == 0)
-     {
- 	tail = gettail(name);
- 	if (len == 0 ? STRLEN(tail) == STRLEN(fb.ff_name)
- 		: (tail - name) + STRLEN(fb.ff_name) < len)
- 	    STRCPY(tail, fb.ff_name);
-     }
- }
- #endif
- 
- /*
-  * return process ID
-  */
-     long
- mch_get_pid(void)
- {
-     return (long)0;
- }
- 
- /*
-  * Change default drive (just like _chdrive of Borland C 3.1)
-  */
-     static int
- change_drive(int drive)
- {
-     union REGS regs;
- 
-     regs.h.ah = 0x0e;
-     regs.h.dl = drive - 1;
-     intdos(&regs, &regs);   /* set default drive */
-     regs.h.ah = 0x19;
-     intdos(&regs, &regs);   /* get default drive */
-     if (regs.h.al == drive - 1)
- 	return 0;
-     return -1;
- }
- 
- /*
-  * Get absolute file name into buffer 'buf' of length 'len' bytes.
-  * All slashes are replaced with backslashes, to avoid trouble when comparing
-  * file names.  When 'shellslash' set do it the other way around.
-  *
-  * return FAIL for failure, OK otherwise
-  */
-     int
- mch_FullName(
-     char_u	*fname,
-     char_u	*buf,
-     int		len,
-     int		force)
- {
-     if (!force && mch_isFullName(fname))	/* already expanded */
-     {
- 	vim_strncpy(buf, fname, len - 1);
- 	slash_adjust(buf);
- 	return OK;
-     }
- 
- #ifdef __BORLANDC__		/* Only Borland C++ has this */
-     if (_fullpath((char *)buf, (char *)fname, len - 1) == NULL)
- 	return FAIL;
-     return OK;
- #else			/* almost the same as mch_FullName() in os_unix.c */
-     {
- # if 1
- 	char_u	fullpath[MAXPATHL];
- 
- 	if (!_truename(fname, fullpath))
- 	    return FAIL;
- 	slash_adjust(fullpath);	    /* Only needed when 'shellslash' set */
- 	vim_strncpy(buf, fullpath, len - 1);
- 	return OK;
- 
- # else  /* Old code, to be deleted... */
- 	int	l;
- 	char_u	olddir[MAXPATHL];
- 	char_u	*p, *q;
- 	int	c;
- 	int	retval = OK;
- 
- 	*buf = 0;
- 	/*
- 	 * change to the directory for a moment,
- 	 * and then do the getwd() (and get back to where we were).
- 	 * This will get the correct path name with "../" things.
- 	 */
- 	p = vim_strrchr(fname, '/');
- 	q = vim_strrchr(fname, '\\');
- 	if (q != NULL && (p == NULL || q > p))
- 	    p = q;
- 	q = vim_strrchr(fname, ':');
- 	if (q != NULL && (p == NULL || q > p))
- 	    p = q;
- 	if (p != NULL)
- 	{
- 	    if (getcwd(olddir, MAXPATHL) == NULL)
- 	    {
- 		p = NULL;	/* can't get current dir: don't chdir */
- 		retval = FAIL;
- 	    }
- 	    else
- 	    {
- 		if (p == fname)			/* /fname	    */
- 		    q = p + 1;			/* -> /		    */
- 		else if (q + 1 == p)		/* ... c:\foo	    */
- 		    q = p + 1;			/* -> c:\	    */
- 		else				/* but c:\foo\bar   */
- 		    q = p;			/* -> c:\foo	    */
- 
- 		c = *q;			/* truncate at start of fname */
- 		*q = NUL;
- # ifdef DJGPP
- 		STRCPY(buf, fname);
- 		slash_adjust(buf);	/* needed when fname starts with \ */
- 		if (mch_chdir(buf))	/* change to the directory */
- # else
- 		if (mch_chdir(fname))	/* change to the directory */
- # endif
- 		    retval = FAIL;
- 		else
- 		{
- 		    fname = q;
- 		    if (c == psepc)	    /* if we cut the name at a */
- 			fname++;	    /* '\', don't add it again */
- 		}
- 		*q = c;
- 	    }
- 	}
- 	if (getcwd(buf, len) == NULL)
- 	{
- 	    retval = FAIL;
- 	    *buf = NUL;
- 	}
- #  ifdef USE_FNAME_CASE
- 	else
- 	{
- 	    char_u	*head;
- 	    char_u	*tail;
- 	    struct ffblk fb;
- 	    int		c;
- 	    int		added;
- 
- 	    /* Apparently "longna~1" isn't expanded by getcwd(), at least not
- 	     * for DJGPP.  Expand it here.  Have to do each dirname
- 	     * separately. */
- 	    slash_adjust(buf);
- 	    head = buf;
- 	    if (isalpha(*head) && head[1] == ':')
- 		head += 2;	/* skip "c:" */
- 	    while (*head != NUL)
- 	    {
- 		/* Advance "head" to the start of a dirname and "tail" to just
- 		 * after it. */
- 		while (*head == '/' || *head == '\\')
- 		    ++head;
- 		for (tail = head; *tail != NUL; ++tail)
- 		    if (*tail == '/' || *tail == '\\')
- 			break;
- 		c = *tail;
- 		*tail = NUL;
- 
- 		if (findfirst(buf, &fb, FA_DIREC) == 0)
- 		{
- 		    added = STRLEN(fb.ff_name);
- 		    if ((head - buf) + added + STRLEN(tail + 1) + 2 < len)
- 		    {
- 			added -= (tail - head);
- 			if (added != 0)
- 			    STRMOVE(tail + 1 + added, tail + 1);
- 			STRCPY(head, fb.ff_name);
- 			tail += added;
- 		    }
- 		}
- 		*tail = c;
- 		head = tail;
- 	    }
- 	}
- #  endif
- 	if (p != NULL)
- 	    mch_chdir(olddir);
- 	/*
- 	 * Concatenate the file name to the path.
- 	 */
- 	if (*fname != NUL)
- 	{
- 	    l = STRLEN(buf);
- 	    if (l > 0 && buf[l - 1] != '/' && buf[l - 1] != '\\')
- 		strcat(buf, pseps);
- 	    strcat(buf, fname);
- 	}
- 	return retval;
- # endif
-     }
- #endif
- }
- 
- /*
-  * Replace all slashes by backslashes.
-  * This used to be the other way around, but MS-DOS sometimes has problems
-  * with slashes (e.g. in a command name).  We can't have mixed slashes and
-  * backslashes, because comparing file names will not work correctly.  The
-  * commands that use a file name should try to avoid the need to type a
-  * backslash twice.
-  * When 'shellslash' set do it the other way around.
-  */
-     void
- slash_adjust(char_u *p)
- {
- #ifdef OLD_DJGPP    /* this seems to have been fixed in DJGPP 2.01 */
-     /* DJGPP can't handle a file name that starts with a backslash, and when it
-      * starts with a slash there should be no backslashes */
-     if (*p == '\\' || *p == '/')
- 	while (*p)
- 	{
- 	    if (*p == '\\')
- 		*p = '/';
- 	    mb_ptr_adv(p);
- 	}
-     else
- #endif
-     while (*p)
-     {
- 	if (*p == psepcN)
- 	    *p = psepc;
- 	mb_ptr_adv(p);
-     }
- }
- 
- /*
-  * Return TRUE if "fname" does not depend on the current directory.
-  */
-     int
- mch_isFullName(char_u *fname)
- {
-     /* A name like "d:/foo" and "//server/share" is absolute */
-     return (fname[0] != NUL && fname[1] == ':'
- 				     && (fname[2] == '/' || fname[2] == '\\'))
- 	|| (fname[0] == fname[1] && (fname[0] == '/' || fname[0] == '\\'));
- }
- 
- 
-     void
- mch_early_init(void)
- {
- }
- 
- /*
-  * Careful: mch_exit() may be called before mch_init()!
-  */
-     void
- mch_exit(int r)
- {
-     settmode(TMODE_COOK);
-     stoptermcap();
-     set_interrupts(FALSE);	    /* restore interrupts */
- #ifdef DJGPP
-     set_sys_cursor();
- #endif
-     /* Somehow outputting CR-NL causes the original colors to be restored */
-     out_char('\r');
-     out_char('\n');
-     out_flush();
-     ml_close_all(TRUE);		    /* remove all memfiles */
- #ifdef MCH_CURSOR_SHAPE
-     mch_restore_cursor_shape(TRUE);
- #endif
-     exit(r);
- }
- 
- /*
-  * set the tty in (raw) ? "raw" : "cooked" mode
-  * Does not change the tty, as bioskey() and kbhit() work raw all the time.
-  */
-     void
- mch_settmode(int tmode)
- {
- }
- 
- #ifdef FEAT_MOUSE
-     void
- mch_setmouse(int on)
- {
-     mouse_active = on;
-     mouse_hidden = TRUE;	/* don't show it until moved */
- }
- #endif
- 
- /*
-  * set screen mode
-  * return FAIL for failure, OK otherwise
-  */
-     int
- mch_screenmode(char_u *arg)
- {
-     int		    mode;
-     int		    i;
-     static char	   *(names[]) = {"BW40", "C40", "BW80", "C80", "MONO", "C4350"};
-     static int	    modes[]   = { BW40,	  C40,	 BW80,	 C80,	MONO,	C4350};
- 
-     mode = -1;
-     if (VIM_ISDIGIT(*arg))		    /* mode number given */
- 	mode = atoi((char *)arg);
-     else
-     {
- 	for (i = 0; i < sizeof(names) / sizeof(char_u *); ++i)
- 	    if (stricmp(names[i], (char *)arg) == 0)
- 	    {
- 		mode = modes[i];
- 		break;
- 	    }
-     }
-     if (mode == -1)
-     {
- 	EMSG("E362: Unsupported screen mode");
- 	return FAIL;
-     }
-     textmode(mode);		    /* use Borland function */
- #ifdef DJGPP
-     /* base address may have changed */
-     get_screenbase();
- #endif
- 
-     /* Screen colors may have changed. */
-     out_str(T_ME);
- 
- #ifdef FEAT_MOUSE
-     if (mode <= 1 || mode == 4 || mode == 5 || mode == 13 || mode == 0x13)
- 	mouse_x_div = 16;
-     else
- 	mouse_x_div = 8;
-     if (mode == 0x11 || mode == 0x12)
- 	mouse_y_div = 16;
-     else if (mode == 0x10)
- 	mouse_y_div = 14;
-     else
- 	mouse_y_div = 8;
-     shell_resized();
- #endif
-     return OK;
- }
- 
- /*
-  * Structure used by Turbo-C/Borland-C to store video parameters.
-  */
- #ifndef DJGPP
- extern struct text_info _video;
- #endif
- 
- /*
-  * try to get the real window size
-  * return FAIL for failure, OK otherwise
-  */
-     int
- mch_get_shellsize(void)
- {
-     struct text_info textinfo;
- 
-     /*
-      * The screenwidth is returned by the BIOS OK.
-      * The screenheight is in a location in the bios RAM, if the display is
-      * EGA or VGA.
-      */
-     if (!term_console)
- 	return FAIL;
-     gettextinfo(&textinfo);
-     Columns = textinfo.screenwidth;
-     Rows = textinfo.screenheight;
- #ifndef DJGPP
-     if (textinfo.currmode > 10)
- 	Rows = *(char far *)MK_FP(0x40, 0x84) + 1;
- #endif
- 
-     if (Columns < MIN_COLUMNS || Rows < MIN_LINES)
-     {
- 	/* these values are overwritten by termcap size or default */
- 	Columns = 80;
- 	Rows = 25;
- 	return FAIL;
-     }
- #ifdef DJGPP
-     mytextinit(&textinfo);   /* Added by JML, 1/15/98 */
- #endif
- 
-     return OK;
- }
- 
- /*
-  * Set the active window for delline/insline.
-  */
-     static void
- set_window(void)
- {
-     if (term_console)
-     {
- #ifndef DJGPP
- 	_video.screenheight = Rows;
- #endif
- 	mywindow(1, 1, Columns, Rows);
-     }
-     screen_start();
- }
- 
-     void
- mch_set_shellsize(void)
- {
-     /* Should try to set the window size to Rows and Columns.
-      * May involve switching display mode....
-      * We assume the user knows the size and just use it. */
- }
- 
- /*
-  * Rows and/or Columns has changed.
-  */
-     void
- mch_new_shellsize(void)
- {
- #ifdef FEAT_MOUSE
-     /* best guess for mouse coordinate computations */
-     if (Columns <= 40)
- 	mouse_x_div = 16;
-     if (Rows == 30)
- 	mouse_y_div = 16;
- #endif
-     set_window();
- #ifdef FEAT_MOUSE
-     mouse_area();	/* set area where mouse can go */
- #endif
- }
- 
- #if defined(DJGPP) || defined(PROTO)
- /*
-  * Check the number of Columns with a BIOS call.  This avoids a crash of the
-  * DOS console when 'columns' is set to a too large value.
-  */
-     void
- mch_check_columns(void)
- {
-     static union REGS	regs;
- 
-     regs.h.ah = 0x0f;
-     (void)int86(0x10, &regs, &regs);
-     if ((unsigned)Columns > (unsigned)regs.h.ah)
- 	Columns = (unsigned)regs.h.ah;
- }
- #endif
- 
- /*
-  * call shell, return FAIL for failure, OK otherwise
-  * options: SHELL_*, see vim.h.
-  */
-     int
- mch_call_shell(
-     char_u	*cmd,
-     int		options)
- {
-     int		x;
-     int		tmode = cur_tmode;
- #ifndef DJGPP
-     char_u	*newcmd;
- #endif
- 
-     out_flush();
- #ifdef DJGPP
-     set_sys_cursor();
- #endif
- 
-     if (options & SHELL_COOKED)
- 	settmode(TMODE_COOK);	/* set to normal mode */
-     set_interrupts(FALSE);	/* restore interrupts */
- 
- #ifdef DJGPP
-     /* ignore signals while external command is running */
-     signal(SIGINT, SIG_IGN);
-     signal(SIGHUP, SIG_IGN);
-     signal(SIGQUIT, SIG_IGN);
-     signal(SIGTERM, SIG_IGN);
- #endif
-     if (cmd == NULL)
- 	x = system((char *)p_sh);
-     else
-     {
- #ifdef DJGPP
- 	/*
- 	 * Use 'shell' for system().
- 	 */
- 	setenv("SHELL", (char *)p_sh, 1);
- 	x = system(cmd);
- #else
- 	/* we use "command" to start the shell, slow but easy */
- 	newcmd = alloc(STRLEN(p_sh) + STRLEN(p_shcf) + STRLEN(cmd) + 3);
- 	if (newcmd == NULL)
- 	    x = -1;
- 	else
- 	{
- 	    sprintf((char *)newcmd, "%s %s %s", p_sh, p_shcf, cmd);
- 	    x = system((char *)newcmd);
- 	    vim_free(newcmd);
- 	}
- #endif
-     }
- #ifdef DJGPP
-     signal(SIGINT, SIG_DFL);
-     signal(SIGHUP, SIG_DFL);
-     signal(SIGQUIT, SIG_DFL);
-     signal(SIGTERM, SIG_DFL);
- #endif
-     if (tmode == TMODE_RAW)
- 	settmode(TMODE_RAW);	/* set to raw mode */
-     set_interrupts(TRUE);	/* catch interrupts */
- 
-     if (x && !(options & SHELL_SILENT) && !emsg_silent)
-     {
- 	MSG_PUTS("\nshell returned ");
- 	msg_outnum((long)x);
- 	msg_putchar('\n');
-     }
- 
-     return x;
- }
- 
- /*
-  * check for an "interrupt signal": CTRL-break or CTRL-C
-  */
-     void
- mch_breakcheck(void)
- {
-     if (ctrlc_pressed)
-     {
- 	ctrlc_pressed = FALSE;
- 	got_int = TRUE;
-     }
- }
- 
- /*
-  * Return TRUE if "p" contain a wildcard that can be expanded by
-  * dos_expandpath().
-  */
-     int
- mch_has_exp_wildcard(char_u *p)
- {
-     for ( ; *p; mb_ptr_adv(p))
-     {
- 	if (vim_strchr((char_u *)"?*[", *p) != NULL
- 		|| (*p == '~' && p[1] != NUL))
- 	    return TRUE;
-     }
-     return FALSE;
- }
- 
- /*
-  * Return TRUE if "p" contain a wildcard or a "~1" kind of thing (could be a
-  * shortened file name).
-  */
-     int
- mch_has_wildcard(char_u *p)
- {
-     for ( ; *p; mb_ptr_adv(p))
-     {
- 	if (vim_strchr((char_u *)
- #  ifdef VIM_BACKTICK
- 				    "?*$[`"
- #  else
- 				    "?*$["
- #  endif
- 						, *p) != NULL
- 		|| (*p == '~' && p[1] != NUL))
- 	    return TRUE;
-     }
-     return FALSE;
- }
- 
- /*
-  * Change directory to "path".
-  * The normal chdir() does not change the default drive.  This one does.
-  * Return 0 for success, -1 for failure.
-  */
-     int
- mch_chdir(char *path)
- {
-     if (path[0] == NUL)		    /* just checking... */
- 	return 0;
-     if (p_verbose >= 5)
-     {
- 	verbose_enter();
- 	smsg((char_u *)"chdir(%s)", path);
- 	verbose_leave();
-     }
-     if (path[1] == ':')		    /* has a drive name */
-     {
- 	if (change_drive(TOLOWER_ASC(path[0]) - 'a' + 1))
- 	    return -1;		    /* invalid drive name */
- 	path += 2;
-     }
-     if (*path == NUL)		    /* drive name only */
- 	return 0;
-     return chdir(path);		    /* let the normal chdir() do the rest */
- }
- 
- #ifdef DJGPP
- /*
-  * mch_rename() works around a bug in rename (aka MoveFile) in
-  * Windows 95: rename("foo.bar", "foo.bar~") will generate a
-  * file whose short file name is "FOO.BAR" (its long file name will
-  * be correct: "foo.bar~").  Because a file can be accessed by
-  * either its SFN or its LFN, "foo.bar" has effectively been
-  * renamed to "foo.bar", which is not at all what was wanted.  This
-  * seems to happen only when renaming files with three-character
-  * extensions by appending a suffix that does not include ".".
-  * Windows NT gets it right, however, with an SFN of "FOO~1.BAR".
-  * This works like mch_rename in os_win32.c, but is a bit simpler.
-  *
-  * Like rename(), returns 0 upon success, non-zero upon failure.
-  * Should probably set errno appropriately when errors occur.
-  */
- 
-     int
- mch_rename(const char *OldFile, const char *NewFile)
- {
-     char_u  *TempFile;
-     int	    retval;
-     int	    fd;
- 
-     /* rename() works correctly without long file names, so use that */
-     if (!_USE_LFN)
- 	return rename(OldFile, NewFile);
- 
-     if ((TempFile = alloc((unsigned)(STRLEN(OldFile) + 13))) == NULL)
- 	return -1;
- 
-     STRCPY(TempFile, OldFile);
-     STRCPY(gettail(TempFile), "axlqwqhy.ba~");
-     if (rename(OldFile, TempFile))
- 	retval = -1;
-     else
-     {
- 	/* now create an empty file called OldFile; this prevents
- 	 * the operating system using OldFile as an alias (SFN)
- 	 * if we're renaming within the same directory.  For example,
- 	 * we're editing a file called filename.asc.txt by its SFN,
- 	 * filena~1.txt.  If we rename filena~1.txt to filena~1.txt~
- 	 * (i.e., we're making a backup while writing it), the SFN
- 	 * for filena~1.txt~ will be filena~1.txt, by default, which
- 	 * will cause all sorts of problems later in buf_write().  So, we
- 	 * create an empty file called filena~1.txt and the system will have
- 	 * to find some other SFN for filena~1.txt~, such as filena~2.txt
- 	 */
- 	if ((fd = open(OldFile, O_RDWR|O_CREAT|O_EXCL, 0444)) < 0)
- 	    return -1;
- 	retval = rename(TempFile, NewFile);
- 	close(fd);
- 	mch_remove((char_u *)OldFile);
- 
- 	/* If renaming to NewFile failed, rename TempFile back to OldFile, so
- 	 * that it looks like nothing happened. */
- 	if (retval)
- 	    rename(TempFile, OldFile);
-     }
-     vim_free(TempFile);
- 
-     return retval;  /* success */
- }
- #endif
- 
- #if defined(DJGPP) || defined(PROTO)
- /*
-  * setlocale() for DJGPP with MS-DOS codepage support
-  * Author: Cyril Slobin <slobin@fe.msk.ru>
-  *
-  * Scaled down a lot for use by Vim: Only support setlocale(LC_ALL, "").
-  */
- 
- #undef setlocale
- 
- #ifndef PROTO
- # include <go32.h>
- # include <inlines/ctype.ha>
- #endif
- #include <locale.h>
- 
- #define UPCASE (__dj_ISALNUM | __dj_ISALPHA | __dj_ISGRAPH | __dj_ISPRINT | __dj_ISUPPER)
- #define LOCASE (__dj_ISALNUM | __dj_ISALPHA | __dj_ISGRAPH | __dj_ISPRINT | __dj_ISLOWER)
- 
-     char *
- djgpp_setlocale(void)
- {
-     __dpmi_regs regs;
-     struct { char id; unsigned short off, seg; } __attribute__ ((packed)) info;
-     unsigned char buffer[0x82], lower, upper;
-     int i;
- 
-     regs.x.ax = 0x6502;
-     regs.x.bx = 0xffff;
-     regs.x.dx = 0xffff;
-     regs.x.cx = 5;
-     regs.x.es = __tb >> 4;
-     regs.x.di = __tb & 0xf;
- 
-     __dpmi_int(0x21, &regs);
- 
-     if (regs.x.flags & 1)
- 	return NULL;
- 
-     dosmemget(__tb, 5, &info);
-     dosmemget((info.seg << 4) + info.off, 0x82, buffer);
- 
-     if (*(short *)buffer != 0x80)
- 	return NULL;
- 
-     /* Fix problem of underscores being replaced with y-umlaut. (Levin) */
-     if (buffer[26] == 0x5f)
- 	buffer[26] = 0x98;
- 
-     for (i = 0; i < 0x80; i++)
-     {
- 	lower = i + 0x80;
- 	upper = (buffer+2)[i];
- 	if (lower != upper)
- 	{
- 	    __dj_ctype_flags[lower+1] = LOCASE;
- 	    __dj_ctype_toupper[lower+1] = upper;
- 	    if (__dj_ctype_flags[upper+1] == 0)
- 		__dj_ctype_flags[upper+1] = UPCASE;
- 	    if (__dj_ctype_tolower[upper+1] == upper)
- 		__dj_ctype_tolower[upper+1] = lower;
- 	}
-     }
- 
-     return "C";
- }
- 
- #if defined(FEAT_CLIPBOARD) || defined(PROTO)
- 
- /*
-  * Clipboard stuff, for cutting and pasting text to other windows.
-  *
-  * Implementation of DOS/Windows clipboard data transfer
-  * by David Kotchan (dkotchan@sympatico.ca)
-  */
- 
- #define CF_TEXT	    0x01    /* Windows clipboard format: Windows (ANSI) text */
- #define CF_OEMTEXT  0x07    /* Windows clipboard format: OEM (DOS) text */
- #define CF_VIMCLIP  0x04    /* trick: SYLK clipboard format for VimClipboard */
- 
- static int Win16OpenClipboard(void);
- static int Win16CloseClipboard(void);
- static int Win16EmptyClipboard(void);
- static char_u *Win16GetClipboardData(int clip_data_format);
- static int Win16SetClipboardData(int clip_data_format, char_u *clip_data, int clip_data_size, int clip_data_type);
- 
- /*
-  * Make vim the owner of the current selection.  Return OK upon success.
-  */
-     int
- clip_mch_own_selection(VimClipboard *cbd)
- {
-     /*
-      * Never actually own the clipboard.  If another application sets the
-      * clipboard, we don't want to think that we still own it.
-      */
-     return FAIL;
- }
- 
- /*
-  * Make vim NOT the owner of the current selection.
-  */
-     void
- clip_mch_lose_selection(VimClipboard *cbd)
- {
-     /* Nothing needs to be done here */
- }
- 
- /*
-  * Read the Windows clipboard text and put it in Vim's clipboard register.
-  */
-     void
- clip_mch_request_selection(VimClipboard *cbd)
- {
-     int		type = MAUTO;
-     char_u	*pAllocated = NULL;
-     char_u	*pClipText = NULL;
-     int		clip_data_format = 0;
- 
-     if (Win16OpenClipboard())
-     {
- 	/* Check for Vim's own clipboard format first.  The CF_VIMCLIP format
- 	 * is just ordinary text (like CF_TEXT) except prepended by the
- 	 * selection type (as a single character).  Note that under DOS we
- 	 * actually cannot define a custom CF_VIMCLIP clipboard format; we
- 	 * use instead one of the existing Windows-defined formats, usually
- 	 * "DIF" or "SYLK".  See Win16GetClipboardData() for details.
- 	 *
- 	 * Note that Win16GetClipboardData() returns the address of the memory
- 	 * block it allocated.  This is not necessary the start of the
- 	 * clipboard text data: there may be other bytes ahead of the
- 	 * text (particularly for CF_VIMCLIP) which are used for data
- 	 * management.  So pClipText is not necessarily == pAllocated.
- 	 */
- 
- 	if ((pAllocated = Win16GetClipboardData(CF_VIMCLIP)) != NULL)
- 	{
- 	    clip_data_format = CF_VIMCLIP;
- 	    pClipText = pAllocated;
- 
- 	    switch (*pClipText++)	/* after ++, pClipText points to text */
- 	    {
- 		default:
- 		case 'L':	type = MLINE;	break;
- 		case 'C':	type = MCHAR;	break;
- 		case 'B':	type = MBLOCK;	break;
- 	    }
- 	}
- 
- 	/* Otherwise, check for the normal Windows text formats.  There are
- 	 * two of these: CF_TEXT (common) and CF_OEMTEXT (used for DOS
- 	 * compatibility).  Experiments show that, under the DOS/Windows
- 	 * clipboard interface, writing CF_TEXT data to the clipboard
- 	 * automatically creates a CF_OEMTEXT format as well.
- 	 */
- 
- 	else if ((pAllocated = Win16GetClipboardData(CF_TEXT)) != NULL)
- 	{
- 	    clip_data_format = CF_TEXT;
- 	    pClipText = pAllocated;
- 	}
- 
- 	else if ((pAllocated = Win16GetClipboardData(CF_OEMTEXT)) != NULL)
- 	{
- 	    clip_data_format = CF_OEMTEXT;
- 	    pClipText = pAllocated;
- 	}
- 
- 	/* Did we get anything? */
- 
- 	if (pClipText != NULL)
- 	{
- 	    char_u *pDest;
- 	    char_u *pStart;
- 	    char_u *pEnd;
- 
- 	    long_u clip_data_size = 0;
- 
- 	    /* The Windows clipboard normally stores its text lines terminated
- 	     * by <CR><NL>.  But Vim uses only <NL>, so translate the <CR><NL>
- 	     * into <NL>.  Also, watch for possible null bytes at the end of
- 	     * pClipText.  These are padding added by "get_clipboard_data"
- 	     * (int 0x2f, AX= 0x1705) in order to round the data size up to the
- 	     * next multiple of 32 bytes.  See Win16GetClipboardData() for
- 	     * details.
- 	     */
- 
- 	    pDest = strstr( pClipText, "\r\n" );    /* find first <CR><NL> */
- 
- 	    if (pDest != NULL)			/* found one? */
- 	    {
- 		pStart = pDest + 1;		/* points to <NL> after <CR> */
- 		pEnd = strstr( pStart, "\r\n" );/* find next <CR><NL> */
- 
- 		while (pEnd != NULL)		/* found one? */
- 		{
- 		    memmove(pDest, pStart, (long)(pEnd - pStart));
- 							/* exclude <CR> */
- 		    pDest += (long)(pEnd - pStart);	/* new destination */
- 		    pStart = pEnd + 1;			/* new starting point */
- 		    pEnd = strstr(pStart, "\r\n");	/* find next <CR><NL> */
- 		}
- 
- 		/* Fell out of while() loop: no more <CR><NL> pairs.  Just copy
- 		 * the rest of the data, up to the first null byte.  */
- 		pEnd = strchr(pStart, '\0');		/* find first null */
- 
- 		memmove(pDest, pStart, (long)(pEnd - pStart)); /* exclude nul */
- 		pDest += (long)(pEnd - pStart);
- 		*pDest = '\0';				    /* terminate */
- 
- 		/* Now that all <CR><NL> pairs have been "compressed" into just
- 		 * <NL>'s, determine the true text length.  */
- 		clip_data_size = (long_u)(pDest - pClipText);
- 	    }
- 	    else
- 	    {
- 		/* no <CR><NL> pairs at all */
- 		/* Since the data may have been padded with trailing nulls,
- 		 * determine the true string length. */
- 		clip_data_size = STRLEN(pClipText);	/* true data length */
- 	    }
- 
- 	    /* Copy the cleaned-up data over to Vim's clipboard "*" register. */
- 	    clip_yank_selection(type, pClipText, clip_data_size, cbd);
- 
- 	    /* Free the memory that Win16GetClipboardData() allocated. */
- 	    vim_free(pAllocated);
- 	}
- 
- 	Win16CloseClipboard();
- 
-     }  // end if (Win16OpenClipboard())
- }
- 
- /*
-  * Send the currently selected Vim text to the Windows clipboard.
-  */
-     void
- clip_mch_set_selection( VimClipboard *cbd )
- {
-     char_u	*pClipData = NULL;
-     long_u	clip_data_size;
-     int		clip_data_type;
- 
-     /* If the '*' register isn't already filled in, fill it in now. */
-     cbd->owned = TRUE;
-     clip_get_selection(cbd);
-     cbd->owned = FALSE;
- 
-     /*
-      * clip_convert_selection() returns a pointer to a buffer containing
-      * the text to send to the Windows clipboard, together with a count
-      * of the number of characters (bytes) in the buffer.  The function's
-      * return value is the 'type' of selection: MLINE, MCHAR, or MBLOCK;
-      * or -1 for failure.
-      */
-     clip_data_type = clip_convert_selection(&pClipData, &clip_data_size, cbd);
- 
-     if (clip_data_type < 0)	    /* could not convert? */
- 	return;			    /* early exit */
- 
-     if (Win16OpenClipboard())
-     {
- 	if (Win16EmptyClipboard())
- 	{
- 	    int sentOK;
- 
- 	    sentOK = Win16SetClipboardData(CF_TEXT, pClipData,
- 					      clip_data_size, clip_data_type);
- 	    sentOK = Win16SetClipboardData(CF_VIMCLIP,
- 			 pClipData, clip_data_size, clip_data_type) && sentOK;
- 
- 	    if (!sentOK)
- 	    {
- 		/* one or both of Win16SetClipboardData() failed. */
- 		/* Technically we don't know why Win16SetClipboardData()
- 		 * failed, but almost always it will be because there wasn't
- 		 * enough DOS memory to buffer the data, so report that as the
- 		 * problem.
- 		 *
- 		 * We report the error here (instead of in
- 		 * Win16SetClipboardData()) because we don't want the error
- 		 * reported twice.
- 		 */
- 		EMSG("E450: Selection too large, cannot allocate DOS buffer");
- 	    }
- 	}
- 
- 	Win16CloseClipboard();
-     }
- 
-     /* release memory allocated by clip_convert_selection() */
-     vim_free(pClipData);
- 
-     return;
- }
- 
- /*
-  * Win16OpenClipboard: open the Windows clipboard.  The clipboard must be open
-  * before it can be communicated with at all.  Return TRUE on success,
-  * FALSE on failure.
-  */
-     static int
- Win16OpenClipboard(void)
- {
-     __dpmi_regs  dpmi_regs;
- 
-     long    start_time;
-     int	    tick_count;
- 
-     /* int 0x2f, AX = 0x1701 attempts to open the Windows clipboard.  Upon
-      * return from the interrupt, if AX is non-zero, the clipboard was
-      * successfully opened.  If AX is zero, the clipboard could not be opened
-      * because it is currently in use by another process.
-      *
-      * Remark: other DOS programs I (dk) have written that use the Windows
-      * clipboard sometimes encounter the problem that the clipboard cannot
-      * be opened even though it is demonstrably not in use by any other
-      * process.  In all cases, repeated attempts to open the clipboard
-      * eventually succeed, but the initial attempt occasionally fails.
-      *
-      * The problem is intermittent and appears to be related to DOS being
-      * "busy" at certain unpredictable times.  DOS maintains two internal
-      * flags that indicate whether it's busy: InDOS and CritErr.  The
-      * location of InDOS can be found by calling int 0x21, AH = 0x34.  The
-      * location of CritErr can be found by calling int 0x21, AX = 0x5d06.
-      * If either of these flags is set, DOS is "busy" and cannot be
-      * interrupted.  See "Undocumented DOS" by Schulman et al for details.
-      *
-      * However here I take the easier approach that if the first call to open
-      * the clipboard does not succeed, just try again.  In fact, try once per
-      * biostime() clock tick, up to 18 times (about one second).
-      */
- 
-     tick_count = 0;
- 
-     dpmi_regs.x.ax = 0x1701;	/* open Windows clipboard */
-     if (__dpmi_int(0x2f, &dpmi_regs) == -1)
-     {
- 	/* real-mode interrupt failed? */
- 	return FALSE;		/* FALSE --> clipboard not open */
-     }
- 
-     /* wait up to one second */
-     while (dpmi_regs.x.ax == 0 && tick_count++ < 18)
-     {
- 	/* Wait one clock tick (18.2 ticks/sec = 55 msec per tick).
- 	 *
- 	 * We busy-wait here.  Unfortunately, delay() and usleep() have been
- 	 * reported to give problems with the original Windows 95.  This is
- 	 * fixed in service pack 1, but not everybody installed that.
- 	 */
- 	start_time = biostime(0, 0L);
- 	while (biostime(0, 0L) == start_time)
- 	    ;
- 
- 	dpmi_regs.x.ax = 0x1701;    /* open Windows clipboard */
- 	if (__dpmi_int(0x2f, &dpmi_regs) == -1)
- 	{
- 	    /* real-mode interrupt failed? */
- 	    return FALSE;		/* FALSE --> clipboard not open */
- 	}
-     }
- 
-     /* Couldn't open the clipboard, even after 18 attempts? */
- 
-     if (tick_count >= 18 && dpmi_regs.x.ax == 0)
- 	return FALSE;		/* FALSE --> clipboard not open */
- 
-     return TRUE;	/* TRUE --> clipboard opened successfully, OK */
- }
- 
- /*
-  * Win16CloseClipboard: close the Windows clipboard.  Return TRUE on
-  * success, FALSE on failure.  This function can always be called,
-  * whether the clipboard is open or not.
-  */
-     static int
- Win16CloseClipboard(void)
- {
-     __dpmi_regs  dpmi_regs;
- 
-     /* Close the clipboard.  This interrupt can always be called, even
-      * if the clipboard is already closed.
-      */
- 
-     dpmi_regs.x.ax = 0x1708;	    /* close the clipboard */
-     if (__dpmi_int(0x2f, &dpmi_regs) == -1)
-     {
- 	/* real-mode interrupt failed? */
- 	return FALSE;		/* FALSE --> clipboard could not be closed */
-     }
- 
-     return TRUE;	/* TRUE --> clipboard closed successfully, OK */
- }
- 
- /*
-  * Win16EmptyClipboard: empty the (previously opened) Windows clipboard.
-  * Return TRUE on success, FALSE on failure.
-  */
-     static int
- Win16EmptyClipboard(void)
- {
-     __dpmi_regs  dpmi_regs;
- 
-     /* int 0x2f, AX = 0x1702 attempts to empty the Windows clipboard.  Upon
-      * return from the interrupt, if AX == 0, the clipboard could not be
-      * emptied (for some reason).
-      */
-     dpmi_regs.x.ax = 0x1702;    /*  empty the Windows clipboard */
-     if (__dpmi_int(0x2f, &dpmi_regs) == -1)
-     {
- 	/* real-mode interrupt failed? */
- 	return FALSE;		/* FALSE --> clipboard could not be emptied */
-     }
- 
-     /* Did we succeed in clearing the clipboard? */
-     if (dpmi_regs.x.ax == 0)
- 	return FALSE;		/* FALSE --> clipboard could not be emptied */
- 
-     return TRUE;		/* TRUE --> clipboard was emptied, OK */
- }
- 
- /*
-  * FreeDOSMemory: a helper function to free memory previously
-  * allocated by a call to __dpmi_allocate_dos_memory().
-  */
-     static void
- FreeDOSMemory(int protected_mode_selector)
- {
-     /* Free the DOS buffer and release the DPMI prot-mode selector.
-      *
-      * It's important that DOS memory be properly released because
-      * there's only a limited amount of it.  Therefore, if the call
-      * to __dpmi_free_dos_memory() fails, emit an error message
-      * unconditionally.
-      */
-     if (__dpmi_free_dos_memory(protected_mode_selector) == -1)
- 	EMSG("E451: could not free DOS memory buffer (DJGPP)");
- }
- 
- /*
-  * Win16GetClipboardData: query the Windows clipboard as to whether data
-  * is available in a particular clipboard format.  If data is
-  * available, allocate a buffer for it and read the data from the
-  * clipboard into the buffer.  Return a pointer to the buffer.  If
-  * no data is available in the requested format, return NULL.
-  *
-  * This routine allocates memory to hold the retrieved clipboard
-  * data.  It's the caller's responsibility to free this memory
-  * once it's finished using it.  The memory should be freed by
-  * calling vim_free().
-  */
-     static char_u *
- Win16GetClipboardData(int clip_data_format)
- {
-     __dpmi_regs  dpmi_regs;
- 
-     int		real_mode_segment_address;
-     int		protected_mode_selector;
- 
-     char_u	*clip_data_buffer;
-     long_u	clip_data_size;
- 
-     /* We only handle clipboard formats we recognize, others are ignored.
-      *
-      * It's not possible to create a custom clipboard format for VimClipboard
-      * data under DOS, so one of the predefined Windows formats had to be
-      * used for CF_VIMCLIP.  Two obscure formats, popular when Windows 3.0
-      * came out but no longer in much use today, are the DIF and SYLK formats.
-      * DIF is the Data Interchange Format, SYLK is the Symbolic Link format.
-      * They are both text formats and either one can be hijacked for use as
-      * "the VimClipboard format".  Of course, this conflicts with anyone who
-      * still *is* using DIF or SYLK data formats, but that will be very few
-      * people.
-      *
-      * I (dk) chose SYLK as the more obscure format because it was used
-      * mostly for Microsoft Multiplan (the pre-cursor to Excel) and it's not
-      * likely Multiplan is used anywhere much anymore.  Mind you, Excel can
-      * still export to both DIF and SYLK formats.
-      */
- 
-     switch (clip_data_format)
-     {
-     case CF_VIMCLIP:		    /* Vim's own special clipboard format */
-     case CF_TEXT:		    /* Windows text */
-     case CF_OEMTEXT:		    /* DOS (OEM) text */
- 
- 	/* int 0x2f, AX = 0x1704 returns the number of bytes of data currently
- 	 * on the Windows clipboard, for the specified format.  Upon return
- 	 * from the interrupt, DX:AX = the number of bytes, rounded up to the
- 	 * nearest multiple of 32.
- 	 */
- 
- 	dpmi_regs.x.ax = 0x1704;    /* get size of clipbd data */
- 	dpmi_regs.x.dx = clip_data_format;
- 	if (__dpmi_int(0x2f, &dpmi_regs) == -1)
- 	{
- 	    /* real-mode interrupt failed? */
- 	    return NULL;				    /* early exit */
- 	}
- 
- 	/* Did we get anything?  If not, this is not an error. */
- 	if (dpmi_regs.x.dx == 0 && dpmi_regs.x.ax == 0)
- 	{
- 	    /* no CF_VIMCLIP data? */
- 	    return NULL;				    /* early exit */
- 	}
- 
- 	/* There is data available in the requested clipboard format.
- 	 *
- 	 * Calculate data size.  Remember this is rounded up to the nearest
- 	 * multiple of 32, so clip_data_size is actually an upper limit.
- 	 * The extra bytes, if any, are set to null (0x00) when the data is
- 	 * read from the clipboard.  (Later:) actually I'm no longer sure
- 	 * this is strictly true: the end-of-data is marked by a null, but
- 	 * the extra bytes appear to sometimes be null, sometimes not.
- 	 * They may just be garbage.
- 	 */
- 	clip_data_size = dpmi_regs.x.ax + (dpmi_regs.x.dx << 16);
- 
- 	/* Allocate memory to retrieve the data.  The buffer has to lie in the
- 	 * DOS memory region (in the first 1 MByte of address space) because
- 	 * the Windows clipboard interface expects a 16-bit segment:offset
- 	 * pointer to a buffer address within the DOS region.  Must therefore
- 	 * use __dpmi_allocate_dos_memory() instead of lalloc() or alloc().
- 	 */
- 	real_mode_segment_address = __dpmi_allocate_dos_memory(
- 		(clip_data_size + 15) >> 4,	/* buffer size, in 16-byte paragraphs */
- 		&protected_mode_selector);	/* prot-mode selector for the address */
- 
- 	if (real_mode_segment_address == -1)
- 	{
- 	    /* memory allocation failed. */
- 
- 	    /* Technically we don't know why the allocation failed, but
- 	     * almost always it will be because there wasn't enough DOS
- 	     * memory to satisfy the request, so report that as the problem.
- 	     * On my system, DJGPP is able to satisfy a DOS allocation request
- 	     * up to about 600K in size.  This depends on your HIMEM.SYS and
- 	     * EMM386.EXE settings however.
- 	     */
- 	    EMSG("E452: Clipboard data too large, cannot allocate DOS buffer");
- 	    return NULL;				    /* early exit */
- 	}
- 
- 	/* Copy data from the clipboard into the buffer.  Experiments show that
- 	 * the Windows clipboard is smart enough to handle data transfers
- 	 * larger than 64K properly, even though the buffer address is a 16-bit
- 	 * segment:offset (which would normally limit the block size to 64K
- 	 * unless ES gets incremented).
- 	 */
- 	dpmi_regs.x.ax = 0x1705;	/* get clipboard data */
- 	dpmi_regs.x.dx = clip_data_format;		/* CF_VIMCLIP */
- 	dpmi_regs.x.es = real_mode_segment_address;	/* buffer ad: segment */
- 	dpmi_regs.x.bx = 0;				/* buffer ad: offset */
- 	if (__dpmi_int( 0x2f, &dpmi_regs) == -1)
- 	{
- 	    /* real-mode interrupt failed? */
- 	    EMSG("E453: could not copy clipboard data to DOS buffer");
- 	    FreeDOSMemory(protected_mode_selector);	/* clean up DOS mem */
- 	    return NULL;				/* early exit */
- 	}
- 
- 	/* Clipboard data is now in DOS memory in the buffer pointed to by
- 	 * ES:BX.  Copy this into ordinary memory that Vim can access (ie.
- 	 * prot-mode memory).  Allocate one extra byte to ensure the text
- 	 * is terminated properly (in case it was somehow corrupted).
- 	 */
- 	clip_data_buffer = (char_u *)lalloc(clip_data_size + 1, TRUE);
- 
- 	if (clip_data_buffer == NULL)
- 	{
- 	    /* allocation failed? */
- 	    EMSG("E454: could not allocate clipboard memory buffer");
- 	    FreeDOSMemory(protected_mode_selector);	/* clean up DOS mem */
- 	    return NULL;				/* early exit */
- 	}
- 
- 	*(clip_data_buffer + clip_data_size) = '\0';	/* ensure terminated */
- 
- 	/* Copy the data from DOS memory to Vim-accessible memory. */
- 	movedata(				/* DJGPP version of memcpy() */
- 		protected_mode_selector, 0, /* source: DOS ad (via selector) */
- 		_my_ds(), (unsigned)clip_data_buffer,
- 						/* target: normal mem address */
- 		clip_data_size);		/* how many bytes */
- 
- 	/* Free the DOS buffer and release the DPMI prot-mode selector. */
- 	FreeDOSMemory(protected_mode_selector);	 /* clean up DOS memory */
- 
- 	return clip_data_buffer;    /* return pointer to allocated buffer */
- 
-     default:		/* unknown clipboard format */
- 	return NULL;
-     }
- }
- 
- /*
-  * Win16SetClipboardData: send 'clip_data_size' bytes of data from the buffer
-  * pointed to by 'clip_data', to the Windows clipboard.  The data is
-  * registered with the clipboard as being in the 'clip_data_format'
-  * format.
-  */
-     static int
- Win16SetClipboardData(
- 	int	clip_data_format,
- 	char_u	*clip_data,
- 	int	clip_data_size,
- 	int	clip_data_type)
- {
-     __dpmi_regs  dpmi_regs;
- 
-     int		real_mode_segment_address;
-     int		protected_mode_selector;
-     long_u	protected_mode_offset = 0L;
-     int		total_size = clip_data_size;
- 
-     char_u	*clip_sel_type;
- 
-     /* If we're using the CF_VIMCLIP custom format, allocate an extra
-      * byte for clip_sel_type, which is a character indicating the type
-      * of text selection: MLINE, MCHAR, or MBLOCK.
-      */
-     if (clip_data_format == CF_VIMCLIP)
- 	total_size++;			/* extra byte for marker */
- 
-     /* Data cannot be sent directly from a Vim string (pClipData) to
-      * the Windows clipboard, because the Windows clipboard interface
-      * expects a 16-bit (DOS) segment:offset address for the source
-      * buffer.  Therefore we must create a "transfer buffer" in the DOS
-      * memory region (in the first 1 MByte of address space) and copy
-      * the Vim string into that.  From there, the data can then be sent
-      * to the Windows clipboard.
-      *
-      * To allocate DOS memory, we must use __dpmi_allocate_dos_memory()
-      * instead of lalloc() or alloc().  If the allocation fails, it will
-      * almost invariably be because there is not enough DOS memory
-      * available to accommodate the size of clip_data.  There is nothing
-      * we can do about this, we simply have to fail.
-      */
-     real_mode_segment_address = __dpmi_allocate_dos_memory(
- 	    (total_size + 15) >> 4,	/* buffer size, in 16-byte paragraphs */
- 	    &protected_mode_selector);	/* prot-mode selector for the address */
- 
-     if (real_mode_segment_address == -1)
-     {
- 	/* memory allocation failed. */
- 	/* Technically we don't know why the allocation failed, but
- 	 * almost always it will be because there wasn't enough DOS
- 	 * memory to satisfy the request.  On my system, DJGPP is able
- 	 * to satisfy a DOS allocation request up to about 600K in size.
- 	 * This depends however on HIMEM.SYS and EMM386.EXE settings.
- 	 */
- 	return FALSE;				/* early exit */
-     }
- 
-     /* Copy data from Vim's buffer (clip_data) into the DOS transfer buffer.
-      * This can be larger than 64K; movedata() takes care of crossing any
-      * 16-bit segment boundaries.
-      *
-      * If we're using Vim's custom clipboard format, we must copy one extra
-      * byte to indicate the type of selection: line, character, or block.
-      */
-     if (clip_data_format == CF_VIMCLIP)
-     {
- 	switch (clip_data_type)
- 	{
- 	    default:
- 	    case MLINE:	    clip_sel_type = "L";	break;
- 	    case MCHAR:	    clip_sel_type = "C";	break;
- 	    case MBLOCK:    clip_sel_type = "B";	break;
- 	}
- 
- 	movedata(
- 		_my_ds(), (unsigned)clip_sel_type,
- 					    /* source: normal memory address */
- 		protected_mode_selector, 0, /* target: DOS ad (via selector) */
- 		1);			    /* how many bytes to copy */
- 
- 	protected_mode_offset += STRLEN(clip_sel_type);	/* allow for marker */
-     }
- 
-     movedata(
- 	_my_ds(), (unsigned)clip_data,	/* source: normal memory address */
- 	protected_mode_selector,	/* target: DOS address (via selector) */
- 	protected_mode_offset,		/* non-zero, if using clip_sel_type */
- 	clip_data_size);		/* how many bytes to copy */
- 
-     /* Send data from the DOS transfer buffer to the Windows clipboard.
-      * int 0x2f, AX = 0x1703 sends SI:CX bytes of data from the buffer
-      * at ES:BX, to the clipboard.
-      */
-     dpmi_regs.x.ax = 0x1703;			/* send clipboard data */
-     dpmi_regs.x.dx = clip_data_format;		/* flag: format of the data */
-     dpmi_regs.x.si = ((total_size >> 16)
- 	    & 0x0000ffffL);			/* hi word of data size */
-     dpmi_regs.x.cx = (total_size & 0x0000ffffL);
- 						/* lo word of data size */
-     dpmi_regs.x.es = real_mode_segment_address;	/* buffer address: segment */
-     dpmi_regs.x.bx = 0;				/* buffer address: offset */
-     if (__dpmi_int(0x2f, &dpmi_regs) == -1)
-     {
- 	/* real-mode interrupt failed. */
- 	FreeDOSMemory(protected_mode_selector);   /* clean up DOS memory */
- 	return FALSE;				  /* early exit */
-     }
- 
-     /* Free the DOS buffer and release the DPMI prot-mode selector. */
-     FreeDOSMemory(protected_mode_selector);	  /* clean up DOS memory */
- 
-     return TRUE;	/* TRUE --> data successfully sent to clipboard */
- }
- 
- #endif	/* FEAT_CLIPBOARD */
- #endif /* DJGPP */
- 
- /* common MS-DOS and Win16 code follows */
- 
-     static int
- vim_chmod(char_u *name)
- {
-     char_u	*p;
-     int		f;
-     int		c = 0;
- 
-     /* chmod() can't handle a file name with a trailing slash, remove it.
-      * But don't remove it for "/" or "c:/". */
-     p = name + STRLEN(name);
-     if (p > name)
- 	--p;
-     if (p > name && (*p == '\\' || *p == '/') && p[-1] != ':')
-     {
- 	c = *p;				/* remove trailing (back)slash */
- 	*p = NUL;
-     }
-     else
- 	p = NULL;
- #if defined(__BORLANDC__) && (__BORLANDC__ > 0x410)
-     /* this also sets the archive bit, supported by Borland C 4.0 and later,
-      * where __BORLANDC__ is 0x450 (3.1 is 0x410) */
-     f = _rtl_chmod((char *)name, 0, 0);
- #else
-     f = _chmod((char *)name, 0, 0);
- #endif
-     if (p != NULL)
- 	*p = c;				/* put back (back)slash */
-     return f;
- }
- 
- /*
-  * get file permissions for 'name'
-  * Returns -1 for error.
-  * Returns FA_attributes defined in dos.h
-  */
-     long
- mch_getperm(char_u *name)
- {
-     return (long)vim_chmod(name);	/* get file mode */
- }
- 
- /*
-  * set file permission for 'name' to 'perm'
-  *
-  * return FAIL for failure, OK otherwise
-  */
-     int
- mch_setperm(
-     char_u	*name,
-     long	perm)
- {
-     perm |= FA_ARCH;	    /* file has changed, set archive bit */
- #if defined(__BORLANDC__) && (__BORLANDC__ > 0x410)
-     return (_rtl_chmod((char *)name, 1, (int)perm) == -1 ? FAIL : OK);
- #else
-     return (_chmod((char *)name, 1, (int)perm) == -1 ? FAIL : OK);
- #endif
- }
- 
- /*
-  * Set hidden flag for "name".
-  */
-     void
- mch_hide(char_u *name)
- {
-     /* DOS 6.2 share.exe causes "seek error on file write" errors when making
-      * the swap file hidden.  Thus don't do it. */
- }
- 
- /*
-  * return TRUE if "name" is a directory
-  * return FALSE if "name" is not a directory
-  * return FALSE for error
-  *
-  * beware of a trailing (back)slash
-  */
-     int
- mch_isdir(char_u *name)
- {
-     int		f;
- 
-     f = vim_chmod(name);
-     if (f == -1)
- 	return FALSE;		    /* file does not exist at all */
-     if ((f & FA_DIREC) == 0)
- 	return FALSE;		    /* not a directory */
-     return TRUE;
- }
- 
- /*
-  * Return 1 if "name" can be executed, 0 if not.
-  * If "use_path" is FALSE only check if "name" is executable.
-  * Return -1 if unknown.
-  */
-     int
- mch_can_exe(
-     char_u	*name,
-     char_u	**path,
-     int		use_path)
- {
-     char	*p;
-     int		mode;
- 
-     if (!use_path)
-     {
- 	/* TODO: proper check if file is executable. */
- 	mode = vim_chmod(name);
- 	return mode != -1 && (mode & FA_DIREC) == 0;
-     }
-     p = searchpath(name);
-     if (p == NULL || mch_isdir(p))
- 	return FALSE;
-     if (path != NULL)
- 	*path = vim_strsave(p);
-     return TRUE;
- }
- 
- /*
-  * Check what "name" is:
-  * NODE_NORMAL: file or directory (or doesn't exist)
-  * NODE_WRITABLE: writable device, socket, fifo, etc.
-  * NODE_OTHER: non-writable things
-  */
-     int
- mch_nodetype(char_u *name)
- {
-     if (STRICMP(name, "AUX") == 0
- 	    || STRICMP(name, "CON") == 0
- 	    || STRICMP(name, "CLOCK$") == 0
- 	    || STRICMP(name, "NUL") == 0
- 	    || STRICMP(name, "PRN") == 0
- 	    || ((STRNICMP(name, "COM", 3) == 0
- 		    || STRNICMP(name, "LPT", 3) == 0)
- 		&& VIM_ISDIGIT(name[3])
- 		&& name[4] == NUL))
- 	return NODE_WRITABLE;
-     /* TODO: NODE_OTHER? */
-     return NODE_NORMAL;
- }
- 
- /*
-  * Get name of current directory into buffer 'buf' of length 'len' bytes.
-  * Return OK for success, FAIL for failure.
-  */
-     int
- mch_dirname(
-     char_u	*buf,
-     int		len)
- {
- #ifdef DJGPP
-     if (getcwd((char *)buf, len) == NULL)
- 	return FAIL;
-     /* turn the '/'s returned by DJGPP into '\'s */
-     slash_adjust(buf);
-     return OK;
- #else
-     return (getcwd((char *)buf, len) != NULL ? OK : FAIL);
- #endif
- }
- 
- /*
-  * this version of remove is not scared by a readonly (backup) file
-  *
-  * returns -1 on error, 0 otherwise (just like remove())
-  */
-     int
- mch_remove(char_u *name)
- {
-     (void)mch_setperm(name, 0);    /* default permissions */
-     return unlink((char *)name);
- }
- 
- /*
-  * Special version of getenv(): Use uppercase name.
-  */
-     char_u *
- mch_getenv(char_u *name)
- {
-     int		i;
- #define MAXENVLEN 50
-     char_u	var_copy[MAXENVLEN + 1];
-     char_u	*p;
-     char_u	*res;
- 
-     /*
-      * Take a copy of the argument, and force it to upper case before passing
-      * to getenv().  On DOS systems, getenv() doesn't like lower-case argument
-      * (unlike Win32 et al.)  If the name is too long to fit in var_copy[]
-      * allocate memory.
-      */
-     if ((i = STRLEN(name)) > MAXENVLEN)
- 	p = alloc(i + 1);
-     else
- 	p = var_copy;
-     if (p == NULL)
- 	p = name;   /* out of memory, fall back to unmodified name */
-     else
-     {
- 	for (i = 0; name[i] != NUL; ++i)
- 	    p[i] = toupper(name[i]);
- 	p[i] = NUL;
-     }
- 
-     res = (char_u *)getenv((char *)p);
- 
-     if (p != var_copy && p != name)
- 	vim_free(p);
- 
-     return res;
- }
- 
- /*
-  * Insert user name in s[len].
-  */
-     int
- mch_get_user_name(
-     char_u	*s,
-     int		len)
- {
-     *s = NUL;
-     return FAIL;
- }
- 
- /*
-  * Insert host name is s[len].
-  */
-     void
- mch_get_host_name(
-     char_u	*s,
-     int		len)
- {
- #ifdef DJGPP
-     vim_strncpy(s, "PC (32 bits Vim)", len - 1);
- #else
-     vim_strncpy(s, "PC (16 bits Vim)", len - 1);
- #endif
- }
--- 0 ----
*** ../vim-7.4.1398/src/os_msdos.h	2016-01-30 21:48:44.329034406 +0100
--- src/os_msdos.h	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,109 ****
- /* vi:set ts=8 sts=4 sw=4:
-  *
-  * VIM - Vi IMproved	by Bram Moolenaar
-  *
-  * Do ":help uganda"  in Vim to read copying and usage conditions.
-  * Do ":help credits" in Vim to see a list of people who contributed.
-  */
- 
- /*
-  * MSDOS Machine-dependent things.
-  */
- 
- #include "os_dos.h"		/* common MS-DOS and Win32 stuff */
- 
- #define BINARY_FILE_IO
- #define USE_EXE_NAME		/* use argv[0] for $VIM */
- #define SYNC_DUP_CLOSE		/* sync() a file with dup() and close() */
- #define USE_TERM_CONSOLE
- #ifdef DJGPP
- # include <fcntl.h>		/* defines _USE_LFN */
- # define USE_LONG_FNAME _USE_LFN    /* decide at run time */
- # define USE_FNAME_CASE
- # define HAVE_PUTENV
- #else
- # define SHORT_FNAME		/* always 8.3 file name */
- #endif
- #define HAVE_STDLIB_H
- #define HAVE_STRING_H
- #define HAVE_FCNTL_H
- #define HAVE_STRCSPN
- #define HAVE_STRICMP
- #define HAVE_STRFTIME		/* guessed */
- #define HAVE_STRNICMP
- #define HAVE_MEMSET
- #define HAVE_QSORT
- #define HAVE_ST_MODE		/* have stat.st_mode */
- #define HAVE_MATH_H
- #if defined(__DATE__) && defined(__TIME__)
- # define HAVE_DATE_TIME
- #endif
- #define BREAKCHECK_SKIP	    1	/* call mch_breakcheck() each time, it's fast */
- #define HAVE_AVAIL_MEM
- 
- /*
-  * Borland C++ 3.1 doesn't have _RTLENTRYF
-  */
- #ifdef __BORLANDC__
- # if __BORLANDC__ < 0x450
- #  define _RTLENTRYF
- # endif
- #endif
- 
- #define FNAME_ILLEGAL "\"*?><|" /* illegal characters in a file name */
- 
- /* cproto fails on missing include files */
- #ifndef PROTO
- # include <dos.h>
- # include <dir.h>
- # include <time.h>
- #endif
- 
- #ifdef DJGPP
- # include <unistd.h>
- # define HAVE_LOCALE_H
- # define setlocale(c, p)    djgpp_setlocale()
- #endif
- 
- #ifndef DJGPP
- typedef long off_t;
- #endif
- 
- /*
-  * Try several directories to put the temp files.
-  */
- #define TEMPDIRNAMES	"$TMP", "$TEMP", "c:\\TMP", "c:\\TEMP", ""
- #define TEMPNAMELEN	128
- 
- #ifndef DFLT_MAXMEM
- # define DFLT_MAXMEM	256		/* use up to 256Kbyte for buffer */
- #endif
- #ifndef DFLT_MAXMEMTOT
- # define DFLT_MAXMEMTOT	0		/* decide in set_init */
- #endif
- 
- #ifdef DJGPP
- # define BASENAMELEN  (_USE_LFN?250:8)	/* length of base of file name */
- #else
- # define BASENAMELEN	    8		/* length of base of file name */
- #endif
- 
- /* codes for msdos mouse event */
- #define MSDOS_MOUSE_LEFT	0x01
- #define MSDOS_MOUSE_RIGHT	0x02
- #define MSDOS_MOUSE_MIDDLE	0x04
- 
- #ifdef DJGPP
- int mch_rename(const char *OldFile, const char *NewFile);
- #else
- # define mch_rename(src, dst) rename(src, dst)
- #endif
- 
- #ifdef DJGPP
- # define vim_mkdir(x, y) mkdir((char *)(x), y)
- #else
- # define vim_mkdir(x, y) mkdir((char *)(x))
- #endif
- #define mch_rmdir(x) rmdir((char *)(x))
- 
- #define mch_setenv(name, val, x) setenv(name, val, x)
--- 0 ----
*** ../vim-7.4.1398/src/proto.h	2016-02-20 22:16:54.086901581 +0100
--- src/proto.h	2016-02-23 13:42:44.288561508 +0100
***************
*** 38,46 ****
  # if defined(UNIX) || defined(__EMX__) || defined(VMS)
  #  include "os_unix.pro"
  # endif
- # if defined(MSDOS)
- #  include "os_msdos.pro"
- # endif
  # ifdef WIN3264
  #  include "os_win32.pro"
  #  include "os_mswin.pro"
--- 38,43 ----
*** ../vim-7.4.1398/src/proto/os_msdos.pro	2016-01-19 13:21:55.845334290 +0100
--- src/proto/os_msdos.pro	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,48 ****
- /* os_msdos.c */
- void mch_set_normal_colors(void);
- void mch_update_cursor(void);
- long_u mch_avail_mem(int special);
- void mch_delay(long msec, int ignoreinput);
- void mch_write(char_u *s, int len);
- int mch_inchar(char_u *buf, int maxlen, long time, int tb_change_cnt);
- int mch_char_avail(void);
- void mch_suspend(void);
- void mch_init(void);
- int mch_check_win(int argc, char **argv);
- int mch_input_isatty(void);
- void fname_case(char_u *name, int len);
- long mch_get_pid(void);
- int mch_FullName(char_u *fname, char_u *buf, int len, int force);
- void slash_adjust(char_u *p);
- int mch_isFullName(char_u *fname);
- void mch_early_init(void);
- void mch_exit(int r);
- void mch_settmode(int tmode);
- void mch_setmouse(int on);
- int mch_screenmode(char_u *arg);
- int mch_get_shellsize(void);
- void mch_set_shellsize(void);
- void mch_new_shellsize(void);
- void mch_check_columns(void);
- int mch_call_shell(char_u *cmd, int options);
- void mch_breakcheck(void);
- int mch_has_exp_wildcard(char_u *p);
- int mch_has_wildcard(char_u *p);
- int mch_chdir(char *path);
- char *djgpp_setlocale(void);
- int clip_mch_own_selection(VimClipboard *cbd);
- void clip_mch_lose_selection(VimClipboard *cbd);
- void clip_mch_request_selection(VimClipboard *cbd);
- void clip_mch_set_selection(VimClipboard *cbd);
- long mch_getperm(char_u *name);
- int mch_setperm(char_u *name, long perm);
- void mch_hide(char_u *name);
- int mch_isdir(char_u *name);
- int mch_can_exe(char_u *name, char_u **path, int use_path);
- int mch_nodetype(char_u *name);
- int mch_dirname(char_u *buf, int len);
- int mch_remove(char_u *name);
- char_u *mch_getenv(char_u *name);
- int mch_get_user_name(char_u *s, int len);
- void mch_get_host_name(char_u *s, int len);
- /* vim: set ft=c : */
--- 0 ----
*** ../vim-7.4.1398/src/regexp.c	2016-02-12 19:08:10.475767012 +0100
--- src/regexp.c	2016-02-23 14:17:42.718869333 +0100
***************
*** 1338,1349 ****
      if (reg(REG_NOPAREN, &flags) == NULL)
  	return NULL;
  
-     /* Small enough for pointer-storage convention? */
- #ifdef SMALL_MALLOC		/* 16 bit storage allocation */
-     if (regsize >= 65536L - 256L)
- 	EMSG_RET_NULL(_("E339: Pattern too long"));
- #endif
- 
      /* Allocate space. */
      r = (bt_regprog_T *)lalloc(sizeof(bt_regprog_T) + regsize, TRUE);
      if (r == NULL)
--- 1338,1343 ----
*** ../vim-7.4.1398/src/screen.c	2016-01-30 20:31:21.257607830 +0100
--- src/screen.c	2016-02-23 14:11:06.718964366 +0100
***************
*** 3191,3205 ****
  	    }
  	}
  
- #ifndef MSDOS
  	/* Check if the character under the cursor should not be inverted */
  	if (!highlight_match && lnum == curwin->w_cursor.lnum && wp == curwin
! # ifdef FEAT_GUI
  		&& !gui.in_use
! # endif
  		)
  	    noinvcur = TRUE;
- #endif
  
  	/* if inverting in this line set area_highlighting */
  	if (fromcol >= 0)
--- 3191,3203 ----
  	    }
  	}
  
  	/* Check if the character under the cursor should not be inverted */
  	if (!highlight_match && lnum == curwin->w_cursor.lnum && wp == curwin
! #ifdef FEAT_GUI
  		&& !gui.in_use
! #endif
  		)
  	    noinvcur = TRUE;
  
  	/* if inverting in this line set area_highlighting */
  	if (fromcol >= 0)
***************
*** 9379,9386 ****
       * ScreenLines[] when t_CV isn't defined.  That's faster than using
       * win_line().
       * Don't use a scroll region when we are going to redraw the text, writing
!      * a character in the lower right corner of the scroll region causes a
!      * scroll-up in the DJGPP version.
       */
      if (scroll_region
  #ifdef FEAT_VERTSPLIT
--- 9377,9384 ----
       * ScreenLines[] when t_CV isn't defined.  That's faster than using
       * win_line().
       * Don't use a scroll region when we are going to redraw the text, writing
!      * a character in the lower right corner of the scroll region may cause a
!      * scroll-up .
       */
      if (scroll_region
  #ifdef FEAT_VERTSPLIT
*** ../vim-7.4.1398/src/structs.h	2016-02-23 13:20:18.466462173 +0100
--- src/structs.h	2016-02-23 14:29:46.723381423 +0100
***************
*** 1845,1853 ****
  #endif
      int		b_p_ro;		/* 'readonly' */
      long	b_p_sw;		/* 'shiftwidth' */
- #ifndef SHORT_FNAME
      int		b_p_sn;		/* 'shortname' */
- #endif
  #ifdef FEAT_SMARTINDENT
      int		b_p_si;		/* 'smartindent' */
  #endif
--- 1845,1851 ----
***************
*** 1983,1991 ****
  				   access b_spell without #ifdef. */
  #endif
  
- #ifndef SHORT_FNAME
      int		b_shortname;	/* this file has an 8.3 file name */
- #endif
  
  #ifdef FEAT_MZSCHEME
      void	*b_mzscheme_ref; /* The MzScheme reference to this buffer */
--- 1981,1987 ----
*** ../vim-7.4.1398/src/syntax.c	2016-01-30 21:10:05.005342537 +0100
--- src/syntax.c	2016-02-23 14:00:10.881745375 +0100
***************
*** 8055,8061 ****
      void
  restore_cterm_colors(void)
  {
! #if defined(MSDOS) || (defined(WIN3264) && !defined(FEAT_GUI_W32))
      /* Since t_me has been set, this probably means that the user
       * wants to use this as default colors.  Need to reset default
       * background/foreground colors. */
--- 8055,8061 ----
      void
  restore_cterm_colors(void)
  {
! #if defined(WIN3264) && !defined(FEAT_GUI_W32)
      /* Since t_me has been set, this probably means that the user
       * wants to use this as default colors.  Need to reset default
       * background/foreground colors. */
*** ../vim-7.4.1398/src/term.c	2016-02-20 22:16:54.086901581 +0100
--- src/term.c	2016-02-23 14:01:14.345089292 +0100
***************
*** 10,16 ****
   *
   * term.c: functions for controlling the terminal
   *
!  * primitive termcap support for Amiga, MSDOS, and Win32 included
   *
   * NOTE: padding and variable substitution is not performed,
   * when compiling without HAVE_TGETENT, we use tputs() and tgoto() dummies.
--- 10,16 ----
   *
   * term.c: functions for controlling the terminal
   *
!  * primitive termcap support for Amiga and Win32 included
   *
   * NOTE: padding and variable substitution is not performed,
   * when compiling without HAVE_TGETENT, we use tputs() and tgoto() dummies.
***************
*** 428,434 ****
  #  endif
  # endif
  
! # if defined(MSDOS) || defined(ALL_BUILTIN_TCAPS) || defined(__EMX__)
  /*
   * These codes are valid when nansi.sys or equivalent has been installed.
   * Function keys on a PC are preceded with a NUL. These are converted into
--- 428,434 ----
  #  endif
  # endif
  
! # if defined(ALL_BUILTIN_TCAPS) || defined(__EMX__)
  /*
   * These codes are valid when nansi.sys or equivalent has been installed.
   * Function keys on a PC are preceded with a NUL. These are converted into
***************
*** 513,619 ****
      {K_PAGEUP,		"\316I"},
  # endif
  
- # if defined(MSDOS)
- /*
-  * These codes are valid for the pc video.  The entries that start with ESC |
-  * are translated into conio calls in os_msdos.c. Default for MSDOS.
-  */
-     {(int)KS_NAME,	"pcterm"},
-     {(int)KS_CE,	"\033|K"},
-     {(int)KS_AL,	"\033|L"},
-     {(int)KS_DL,	"\033|M"},
- #  ifdef TERMINFO
-     {(int)KS_CS,	"\033|%i%p1%d;%p2%dr"},
- #   ifdef FEAT_VERTSPLIT
-     {(int)KS_CSV,	"\033|%i%p1%d;%p2%dV"},
- #   endif
- #  else
-     {(int)KS_CS,	"\033|%i%d;%dr"},
- #   ifdef FEAT_VERTSPLIT
-     {(int)KS_CSV,	"\033|%i%d;%dV"},
- #   endif
- #  endif
-     {(int)KS_CL,	"\033|J"},
-     {(int)KS_ME,	"\033|0m"},	/* normal */
-     {(int)KS_MR,	"\033|112m"},	/* reverse: black on lightgrey */
-     {(int)KS_MD,	"\033|15m"},	/* bold: white text */
-     {(int)KS_SE,	"\033|0m"},	/* standout end */
-     {(int)KS_SO,	"\033|31m"},	/* standout: white on blue */
-     {(int)KS_CZH,	"\033|225m"},	/* italic mode: blue text on yellow */
-     {(int)KS_CZR,	"\033|0m"},	/* italic mode end */
-     {(int)KS_US,	"\033|67m"},	/* underscore mode: cyan text on red */
-     {(int)KS_UE,	"\033|0m"},	/* underscore mode end */
-     {(int)KS_CCO,	"16"},		/* allow 16 colors */
- #  ifdef TERMINFO
-     {(int)KS_CAB,	"\033|%p1%db"},	/* set background color */
-     {(int)KS_CAF,	"\033|%p1%df"},	/* set foreground color */
- #  else
-     {(int)KS_CAB,	"\033|%db"},	/* set background color */
-     {(int)KS_CAF,	"\033|%df"},	/* set foreground color */
- #  endif
-     {(int)KS_MS,	"y"},
-     {(int)KS_UT,	"y"},
-     {(int)KS_LE,	"\b"},
- #  ifdef TERMINFO
-     {(int)KS_CM,	"\033|%i%p1%d;%p2%dH"},
- #  else
-     {(int)KS_CM,	"\033|%i%d;%dH"},
- #  endif
- #ifdef DJGPP
-     {(int)KS_VB,	"\033|B"},	/* visual bell */
- #endif
-     {K_UP,		"\316H"},
-     {K_DOWN,		"\316P"},
-     {K_LEFT,		"\316K"},
-     {K_RIGHT,		"\316M"},
-     {K_S_LEFT,		"\316s"},
-     {K_S_RIGHT,		"\316t"},
-     {K_S_TAB,		"\316\017"},
-     {K_F1,		"\316;"},
-     {K_F2,		"\316<"},
-     {K_F3,		"\316="},
-     {K_F4,		"\316>"},
-     {K_F5,		"\316?"},
-     {K_F6,		"\316@"},
-     {K_F7,		"\316A"},
-     {K_F8,		"\316B"},
-     {K_F9,		"\316C"},
-     {K_F10,		"\316D"},
-     {K_F11,		"\316\205"},
-     {K_F12,		"\316\206"},
-     {K_S_F1,		"\316T"},
-     {K_S_F2,		"\316U"},
-     {K_S_F3,		"\316V"},
-     {K_S_F4,		"\316W"},
-     {K_S_F5,		"\316X"},
-     {K_S_F6,		"\316Y"},
-     {K_S_F7,		"\316Z"},
-     {K_S_F8,		"\316["},
-     {K_S_F9,		"\316\\"},
-     {K_S_F10,		"\316]"},
-     {K_S_F11,		"\316\207"},
-     {K_S_F12,		"\316\210"},
-     {K_INS,		"\316R"},
-     {K_DEL,		"\316S"},
-     {K_HOME,		"\316G"},
-     {K_END,		"\316O"},
-     {K_PAGEDOWN,	"\316Q"},
-     {K_PAGEUP,		"\316I"},
-     {K_KPLUS,		"\316N"},
-     {K_KMINUS,		"\316J"},
-     {K_KMULTIPLY,	"\3167"},
-     {K_K0,		"\316\332"},
-     {K_K1,		"\316\336"},
-     {K_K2,		"\316\342"},
-     {K_K3,		"\316\346"},
-     {K_K4,		"\316\352"},
-     {K_K5,		"\316\356"},
-     {K_K6,		"\316\362"},
-     {K_K7,		"\316\366"},
-     {K_K8,		"\316\372"},
-     {K_K9,		"\316\376"},
- # endif
- 
  # if defined(WIN3264) || defined(ALL_BUILTIN_TCAPS) || defined(__EMX__)
  /*
   * These codes are valid for the Win32 Console .  The entries that start with
--- 513,518 ----
***************
*** 1369,1378 ****
  # define DEFAULT_TERM	(char_u *)"win32"
  #endif
  
- #ifdef MSDOS
- # define DEFAULT_TERM	(char_u *)"pcterm"
- #endif
- 
  #if defined(UNIX) && !defined(__MINT__)
  # define DEFAULT_TERM	(char_u *)"ansi"
  #endif
--- 1268,1273 ----
***************
*** 1971,1977 ****
  	/* termcap failed to report size */
  	/* set defaults, in case ui_get_shellsize() also fails */
  	width = 80;
! #if defined(MSDOS) || defined(WIN3264)
  	height = 25;	    /* console is often 25 lines */
  #else
  	height = 24;	    /* most terminals are 24 lines */
--- 1866,1872 ----
  	/* termcap failed to report size */
  	/* set defaults, in case ui_get_shellsize() also fails */
  	width = 80;
! #if defined(WIN3264)
  	height = 25;	    /* console is often 25 lines */
  #else
  	height = 24;	    /* most terminals are 24 lines */
***************
*** 4482,4488 ****
  	    if (key_name[0] == (int)KS_MOUSE)
  	    {
  		/*
! 		 * For xterm and MSDOS we get "<t_mouse>scr", where
  		 *  s == encoded button state:
  		 *	   0x20 = left button down
  		 *	   0x21 = middle button down
--- 4377,4383 ----
  	    if (key_name[0] == (int)KS_MOUSE)
  	    {
  		/*
! 		 * For xterm we get "<t_mouse>scr", where
  		 *  s == encoded button state:
  		 *	   0x20 = left button down
  		 *	   0x21 = middle button down
***************
*** 4646,4652 ****
  #endif
  	    )
  	{
! #  if !defined(MSWIN) && !defined(MSDOS)
  		/*
  		 * Handle mouse events.
  		 * Recognize the xterm mouse wheel, but not in the GUI, the
--- 4541,4547 ----
  #endif
  	    )
  	{
! #  if !defined(MSWIN)
  		/*
  		 * Handle mouse events.
  		 * Recognize the xterm mouse wheel, but not in the GUI, the
*** ../vim-7.4.1398/src/undo.c	2016-02-19 22:46:30.604057948 +0100
--- src/undo.c	2016-02-23 14:11:32.418698618 +0100
***************
*** 641,649 ****
  	u_getbot();
      }
  
! #if !defined(UNIX) && !defined(DJGPP) && !defined(WIN32) && !defined(__EMX__)
  	/*
! 	 * With Amiga and MSDOS 16 bit we can't handle big undo's, because
  	 * then u_alloc_line would have to allocate a block larger than 32K
  	 */
      if (size >= 8000)
--- 641,649 ----
  	u_getbot();
      }
  
! #if !defined(UNIX) && !defined(WIN32) && !defined(__EMX__)
  	/*
! 	 * With Amiga we can't handle big undo's, because
  	 * then u_alloc_line would have to allocate a block larger than 32K
  	 */
      if (size >= 8000)
*** ../vim-7.4.1398/src/uninstal.c	2010-08-08 15:17:41.000000000 +0200
--- src/uninstal.c	2016-02-23 14:12:50.993886100 +0100
***************
*** 289,329 ****
      static void
  delete_uninstall_key(void)
  {
- #ifdef WIN3264
      reg_delete_key(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Vim " VIM_VERSION_SHORT);
- #else
-     FILE	*fd;
-     char	buf[BUFSIZE];
- 
-     /*
-      * On DJGPP we delete registry entries by creating a .inf file and
-      * installing it.
-      */
-     fd = fopen("vim.inf", "w");
-     if (fd != NULL)
-     {
- 	fprintf(fd, "[version]\n");
- 	fprintf(fd, "signature=\"$CHICAGO$\"\n\n");
- 	fprintf(fd, "[DefaultInstall]\n");
- 	fprintf(fd, "DelReg=DeleteMe\n\n");
- 	fprintf(fd, "[DeleteMe]\n");
- 	fprintf(fd, "HKLM,\"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Vim " VIM_VERSION_SHORT "\"\n");
- 	fclose(fd);
- 
- 	/* Don't know how to detect Win NT with DJGPP.  Hack: Just try the Win
- 	 * 95/98/ME method, since the DJGPP version can't use long filenames
- 	 * on Win NT anyway. */
- 	sprintf(buf, "rundll setupx.dll,InstallHinfSection DefaultInstall 132 %s\\vim.inf", installdir);
- 	run_command(buf);
- #if 0
- 	/* Windows NT method (untested). */
- 	sprintf(buf, "rundll32 syssetup,SetupInfObjectInstallAction DefaultInstall 128 %s\\vim.inf", installdir);
- 	run_command(buf);
- #endif
- 
- 	remove("vim.inf");
-     }
- #endif
  }
  
      int
--- 289,295 ----
*** ../vim-7.4.1398/src/version.c	2016-02-23 13:20:18.470462131 +0100
--- src/version.c	2016-02-23 14:48:40.159635559 +0100
***************
*** 3709,3721 ****
  #  endif
  # endif
  #endif
- #ifdef MSDOS
- # ifdef DJGPP
-     MSG_PUTS(_("\n32-bit MS-DOS version"));
- # else
-     MSG_PUTS(_("\n16-bit MS-DOS version"));
- # endif
- #endif
  #ifdef MACOS
  # ifdef MACOS_X
  #  ifdef MACOS_X_UNIX
--- 3711,3716 ----
*** ../vim-7.4.1398/src/vim.h	2016-02-20 22:16:54.086901581 +0100
--- src/vim.h	2016-02-23 14:15:11.488433253 +0100
***************
*** 27,34 ****
  # endif
  #endif
  
! #if defined(MSDOS) || defined(WIN32) || defined(_WIN64) \
! 	|| defined(__EMX__)
  # include "vimio.h"
  #endif
  
--- 27,33 ----
  # endif
  #endif
  
! #if defined(WIN32) || defined(_WIN64) || defined(__EMX__)
  # include "vimio.h"
  #endif
  
***************
*** 164,184 ****
  #ifdef WIN3264
  # define VIM_SIZEOF_INT 4
  #endif
- #ifdef MSDOS
- # ifdef DJGPP
- #  ifndef FEAT_GUI_GTK		/* avoid problems when generating prototypes */
- #   define VIM_SIZEOF_INT 4	/* 32 bit ints */
- #  endif
- #  define DOS32
- #  define FEAT_CLIPBOARD
- # else
- #  ifndef FEAT_GUI_GTK		/* avoid problems when generating prototypes */
- #   define VIM_SIZEOF_INT 2	/* 16 bit ints */
- #  endif
- #  define SMALL_MALLOC		/* 16 bit storage allocation */
- #  define DOS16
- # endif
- #endif
  
  #ifdef AMIGA
    /* Be conservative about sizeof(int). It could be 4 too. */
--- 163,168 ----
***************
*** 303,312 ****
  # include "os_amiga.h"
  #endif
  
- #ifdef MSDOS
- # include "os_msdos.h"
- #endif
- 
  #ifdef WIN3264
  # include "os_win32.h"
  #endif
--- 287,292 ----
***************
*** 462,472 ****
  #ifdef _DCC
  # include <sys/stat.h>
  #endif
! #if defined(MSDOS) || defined(MSWIN)
  # include <sys/stat.h>
  #endif
  
! #if defined(HAVE_ERRNO_H) || defined(DJGPP) \
  	|| defined(WIN32) || defined(_WIN64) || defined(__EMX__)
  # include <errno.h>
  #endif
--- 442,452 ----
  #ifdef _DCC
  # include <sys/stat.h>
  #endif
! #if defined(MSWIN)
  # include <sys/stat.h>
  #endif
  
! #if defined(HAVE_ERRNO_H) \
  	|| defined(WIN32) || defined(_WIN64) || defined(__EMX__)
  # include <errno.h>
  #endif
*** ../vim-7.4.1398/src/window.c	2016-01-30 21:29:52.232928463 +0100
--- src/window.c	2016-02-23 14:02:07.912535468 +0100
***************
*** 6438,6444 ****
  	/* something failed; use the file name (truncate when too long) */
  	vim_strncpy(buf, fname, len - 1);
      }
! #if defined(MACOS_CLASSIC) || defined(MSDOS) || defined(MSWIN)
      slash_adjust(buf);
  #endif
      return retval;
--- 6438,6444 ----
  	/* something failed; use the file name (truncate when too long) */
  	vim_strncpy(buf, fname, len - 1);
      }
! #if defined(MACOS_CLASSIC) || defined(MSWIN)
      slash_adjust(buf);
  #endif
      return retval;
*** ../vim-7.4.1398/src/xxd/Make_bc3.mak	2010-05-15 13:04:06.000000000 +0200
--- src/xxd/Make_bc3.mak	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,31 ****
- # Simple makefile for Borland C++ 4.0
- # 3.1 can NOT be used, it has problems with the fileno() define.
- 
- # Command line variables:
- # BOR		path to root of Borland C (E:\BORLANDC)
- # DEBUG		set to "yes" for debugging (no)
- 
- !ifndef BOR
- BOR	= e:\bc4
- !endif
- 
- !if ("$(DEBUG)" == "yes")
- DEBUG_FLAG = -v -DDEBUG
- !else
- DEBUG_FLAG =
- !endif
- 
- CC	= $(BOR)\bin\bcc
- INC	= -I$(BOR)\include
- LIB	= -L$(BOR)\lib
- 
- # The following compile options can be changed for better machines.
- #	replace -1- with -2 to produce code for a 80286 or higher
- #	replace -1- with -3 to produce code for a 80386 or higher
- #	add -v for source debugging
- OPTIMIZE= -1- -Ox
- 
- CFLAGS	= -A -mc -DMSDOS $(DEBUG_FLAG) $(OPTIMIZE) $(INC) $(LIB)
- 
- xxd.exe: xxd.c
- 	$(CC) $(CFLAGS) xxd.c
--- 0 ----
*** ../vim-7.4.1398/src/xxd/Make_djg.mak	2010-05-15 13:04:06.000000000 +0200
--- src/xxd/Make_djg.mak	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,9 ****
- # The most simplistic Makefile, for DJGPP on MS-DOS
- 
- CFLAGS = -O2 -Wall
- 
- xxd.exe: xxd.c
- 	gcc $(CFLAGS) -s -o xxd.exe xxd.c -lpc
- 
- clean:
- 	del xxd.exe
--- 0 ----
*** ../vim-7.4.1398/src/version.c	2016-02-23 13:20:18.470462131 +0100
--- src/version.c	2016-02-23 14:48:40.159635559 +0100
***************
*** 750,751 ****
--- 750,753 ----
  {   /* Add new patch number below this line */
+ /**/
+     1399,
  /**/

-- 
We learn from our mistakes.  Politicians don't make mistakes.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
